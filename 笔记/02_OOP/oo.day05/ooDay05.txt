回顾:
1.内存管理:JVM
  1)堆:所有new出来的对象(包括实例变量)
  2)栈:正在调用中的方法中的所有局部变量(包括参数)
  3)方法区:.class字节码文件(包括方法、静态变量)
2.方法的重写(Override):
  1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
  2)重写方法被调用时，看对象的类型
3.重写与重载的区别:
  1)重写(Override):
    1.1)发生在父子类中，方法名称相同，参数列表相同，方法体不同
	1.2)运行期绑定，看对象的类型调用方法
  2)重载(Overload):
    2.1)发生在一个类中，方法名称相同，参数列表不同，方法体不同
	2.2)编译期绑定，看引用的类型绑定方法
4.package和import:
5.访问控制修饰符:
  1)public:公开的，任何类
  2)private:私有的，本类
  3)protected:受保护的，本类、子类、同包类
  4)默认的:什么也不写，本类、同包类
6.static:静态的
  1)静态变量:
      static，类，方法区，一份，类名点来访问
	  所有对象共享的数据(图片、音频、视频...)
  2)静态方法:
      static，类，方法区，一份，类名点来访问
	  没有隐式this传递，静态方法中不能直接访问实例成员
	  方法的操作仅与参数相关而与对象无关
  3)静态块:
      static，类，类被加载期间自动执行，只执行一次
	  初始化静态资源(图片、音频、视频...)





笔记:
1.final:最终的、不可变的------单独应用几率不高
  1)修饰变量:变量不可被改变
  2)修饰方法:方法不可被重写
  3)修饰类:类不可被继承
2.static final常量: 应用率高
  1)常量必须声明同时初始化
  2)通过类名点来访问，不可被改变
  3)建议:常量名所有字母都大写，多个单词用_分隔
  4)编译器在编译时将常量直接替换为具体的值，效率高
3.抽象方法:
  1)由abstract修饰
  2)只有方法的定义，没有方法的具体实现(连{}都没有)
4.抽象类:
  1)由abstract修饰
  2)包含抽象方法的类必须是抽象类
    不包含抽象方法的类也可以声明为抽象类----我乐意
  3)抽象类不能被实例化
  4)抽象类是需要被继承的，子类:
    4.1)重写所有抽象方法------常用
	4.2)也声明为抽象类--------不常用
  5)抽象类的意义:
    5.1)封装子类共有的属性和行为-------代码复用
	5.2)为所有子类提供一种统一的类型---向上造型
	5.3)可以包含抽象方法，为所有子类提供了统一的入口
	    每个子类的实现不同，但入口是一致的
5.接口:
  1)是一个标准、规范----制定方
    遵守了这个标准就能干某件事---------API
  2)是一种数据类型(引用类型)
  3)由interface定义
    只能包含常量和抽象方法
  4)接口不能被实例化
  5)接口是需要被实现/继承的，实现类/子类:
      必须重写接口中的所有抽象方法
  6)一个类可以实现多个接口，用逗号分隔
    若又继承又实现时，应先继承后实现
  7)接口可以继承接口




练习:
1.完成UnionPayTest银行卡系统
2.创建oo.day06包，重写完成UnionPayTest银行卡系统
3.完成ShapeTest求图形的最大面积
4.自学(抽象类与接口的区别)












interface UnionPay{ //银联接口
  void 存款();
  void 取款();
  void 转帐();
  void 查询余额();
}
interface ABC extends UnionPay{ //农行接口
  void 支付电话费();
}
interface ICBC extends UnionPay{ //工行接口
  void 在线支付();
}

class ABCImpl implements ABC{ //农行卡
  public void 存款(){}
  public void 取款(){}
  public void 转帐(){}
  public void 查询余额(){}
  public void 支付电话费(){}
}
class ICBCImpl implements ICBC{ //工行卡
  public void 存款(){}
  public void 取款(){}
  public void 转帐(){}
  public void 查询余额(){}
  public void 在线支付(){}
}







UnionPayTest


卡的余额-要取的钱
  ---------------等于0(取完以后没钱了)
卡的余额-要取的钱
  ---------------大于2000(取完以后至少剩2000)
卡的余额-要取的钱
  ---------------大于-2000(取完以后欠2000)


double num = scan.nextDouble();












InterfaceDemo









接口是完全抽象的抽象类
















类和类---------------继承extends
接口和接口-----------继承extends
类和接口-------------实现implements



Inter2 o1 = new Aoo(); //向上造型(直接造型)
Inter1 o2 = new Aoo(); //向上造型(间接造型)


interface Inter1{
  void show();
}
interface Inter2 extends Inter1{
  void test();
}
class Aoo implements Inter2{
  public void test(){}
  public void show(){}
}










interface Inter1{
  void show();
}
interface Inter2{
  void test();
}
abstract class Aoo{
  abstract void say();
}
class Boo extends Aoo implements Inter1,Inter2{
  public void show(){}
  public void test(){}
  void say(){}
}










家具-----------国家


红星美凯龙
集美















interface Inter1{
  void show();
  void say();
}
class Aoo implements Inter1{
  public void show(){}
  public void say(){}
}













interface Inter1{
  public static final int NUM = 5;
  public abstract void show();
  int COUNT = 6; //默认public static final
  void say(); //默认public abstract
  //int NUMBER; //编译错误，常量必须声明同时初始化
  //void sayHi(){} //编译错误，抽象方法不能有方法体
}
















生活中的接口:
1)电脑厂商留了个USB接口---------制定标准、规范
  优盘、鼠标、摄像头等厂商------遵守标准、规范
2)国家对开发商------------------制定标准、规范
  国家对家具厂商----------------制定标准、规范
  开发商、家具厂商--------------遵守标准、规范  
3)银行---------------------------制定标准、规范
  银行卡-------------------------遵守标准、规范












ShapeTest













new Tetromino(); //编译错误

new T();
new J();
new L();
new I();
new O();
new S();
new Z();

abstract class Tetromino{
  Cell[] cells;
  Tetromino(){
  }
  void drop(){}
  void moveLeft(){}
  void moveRight(){}
  void print(){}
}
















求一组图形中的最大面积:
Square[] ss = new Square[3];
ss[0] = new Square(1);
ss[1] = new Square(2);
ss[2] = new Square(3);

Circle[] cs = new Circle[3];
cs[0] = new Circle(1);
cs[1] = new Circle(2);
cs[2] = new Cricle(3);

Six[] sixes = new Six[3];
sixes[0] = new Six(1);
sixes[1] = new Six(2);
sixes[2] = new Six(3);

1)先找到ss中的最大面积sMax
2)再找到cs中的最大面积cMax
3)再找到sixes中的最大面积sixMax
4)找到sMax与cMax与sixMax中的最大面积max




//复用性差，扩展性差，维护性差












Shape s1 = new Square(1); //向上造型
Shape s2 = new Circle(1); //向上造型
Shape s3 = new Six(1);    //向上造型

new Shape(); //编译错误

Shape[] shapes = new Shape[9]; //创建Shape数组对象
shapes[0] = new Square(1); //向上造型
shapes[1] = new Square(2);
shapes[2] = new Square(3);
shapes[3] = new Circle(1);
shapes[4] = new Circle(2);
shapes[5] = new Circle(3);
shapes[6] = new Six(1);
shapes[7] = new Six(2);
shapes[8] = new Six(3);

double max = shapes[0].area(); //表示能点出来了
for(int i=1;i<shapes.length;i++){
  double area = shapes[i].area();
  if(area>max){
    max=area;
  }
}
System.out.println("最大面积为:"+max);






abstract class Shape{ //抽象类---不完整
  double c;
  abstract double area(); //抽象方法---不完整
}

class Square extends Shape{
  double area(){ //重写--变不完整为完整
    return 0.0625*c*c;
  }
}
class Circle extends Shape{
  double area(){
    return 0.0796*c*c;
  }
}
class Six extends Shape{
  double area(){
    return 0.0721*c*c;
  }
}



















abstract class Shape{ //抽象类---不完整
  double c;
  abstract double area(); //抽象方法---不完整
}

class Square extends Shape{ //方形
  double area(){ //重写----变不完整为完整
    return 0.0625*c*c;
  }
}
class Circle extends Shape{ //圆形
  double area(){
    return 0.0796*c*c;
  }
}








new Shape(); //编译错误
Shape s; //正确












new Car(); //不合理

abstract class Car{
  ...
  void run(){ ... }
  abstract void stop();
}













STUDENT_NAME
STU_ID








继承要符合is a的关系

class Dog{
  String name;
  int age;
  String address;
  void eat(){}
  void sleep(){}
}
class Person extends Dog{ //不能单单为了复用代码而继承
}
















package a;
class Aoo{
}

package b;
class Aoo{
}

package c;
class Coo{
  a.Aoo o = new a.Aoo();
}











