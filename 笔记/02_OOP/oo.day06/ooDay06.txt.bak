回顾:
1.final:最终的
   变量不可被改变、方法不可被重写、类不可被继承
2.static final常量:
   必须声明同时初始化、类名点来访问、不能改
   所有字母大写
   编译器在编译时被自动替换为具体的值、效率高
3.抽象方法:
   abstract,只有方法的定义，没有具体的实现
4.抽象类:
   abstract，包含抽象方法的类必须是抽象类
   不能被实例化，是需要被继承的，子类
     1)重写所有抽象方法
	 2)也声明为抽象类
   意义:
     1)封装共有的属性和行为---------代码复用
	 2)为所有子类提供统一的类型-----向上造型
	 3)包含抽象方法，为所有子类提供统一的入口
	   子类的具体实现不同，但入口是一致的
5.接口:
   标准、规范，引用数据类型
   interface定义，只能包含抽象方法和常量
   不能被实例化，是需要被实现的，实现类:
     必须重写所有抽象方法
   一个类可以实现多个接口，用逗号分隔
   若又继承又实现时，应先继承后实现
   接口可以继承接口



正课:
1.多态:多种形态
  1)意义:
    1.1)同一个类型的引用指向不同的对象时，有不同的实现
	    -----行为的多态:cut()、run()、study()......
	1.2)同一个对象被造型为不同的类型时，有不同的功能
	    -----对象的多态:我、水、你......
  2)向上造型(自动类型转换):
    2.1)父类型的引用指向子类的对象
	2.2)能造型成为的类型有: 父类、所实现的接口
	2.3)能点出来什么，看引用的类型
  3)强制类型转换，成功的条件有两点:
    3.1)引用所指向的对象，就是该类型
	3.2)引用所指向的对象，实现了该接口
  4)强转时若不符合如下两个条件，则发生ClassCastException类型转换异常
    建议在强转之前先通过instanceof判断引用指向的对象是否是该类型
2.成员内部类:应用率不高
  1)类中套类，外面的称为外部类，里面的称为内部类
  2)内部类通常只服务于外部类，对外不具备可见性
  3)内部类通常只在外部类中被创建
  4)内部类中可以直接访问外部类的成员(包括私有的)
    内部类中有个隐式的引用指向了创建它的外部类对象
	  语法: 外部类名.this.
3.匿名内部类:应用率比较高
  1)若想创建一个类的对象，并且对象只被创建一次，
    此时该类不必命名，称之为匿名内部类对象
  2)匿名内部类中访问外部的变量，该变量必须是final的


面向对象三大特征:
1.封装:
  1)类:封装的是对象的属性和行为
  2)方法:封装的是具体的业务逻辑功能
  3)访问控制修饰符:封装的是访问的权限
2.继承:
  1)作用:代码的复用
  2)父类:所有子类共有的属性和行为
    子类:子类所特有的属性和行为
  3)子继承父后，子具有:父类+子类
  4)单一继承、多接口实现，传递性
3.多态:
  1)意义:行为的多态、对象的多态
  2)向上造型、强制类型转换、instanceof
  3)多态的表现形式:
    3.1)重写:主要是依据对象
	3.2)重载:主要是依据参数


面向对象课程安排:
第一天:
  1.什么是类？什么是对象？
  2.如何创建类？如何创建对象？如何访问成员？
  3.引用类型之间画等号
  4.null和NullPointerException
第二天:
  1.方法的重载
  2.构造方法
  3.this
  4.引用类型数组
第三天:
  1.内存管理
  2.继承
  3.super
  4.向上造型
第四天:
  1.方法的重写
  2.重写与重载的区别
  3.package和import
  4.访问控制修饰符
  5.static
  6.final
  7.static final
第五天:
  1.抽象方法
  2.抽象类
  3.接口
  4.抽象类与接口的区别
第六天:
  1.多态:意义、向上造型、强制类型转换、instanceof
  2.内部类:成员内部类、匿名内部类




练习:
1.完成农行ATM的完整代码----两次
2.面向对象总结
3.运行ShootGame游戏，了解需求

课后作业:第2题不用写












设计规则:
1)所有子类共有的属性和行为，抽象到父类中
2)所有子类行为都一样-----设计为普通方法
  所有子类行为不一样-----设计为抽象方法
3)部分子类共有的行为，抽象到接口中
  符合既是也是原则时，使用接口
  接口是对继承的单根性的扩展----多继承












println()依据参数的不同，实现也不同

System.out.println();
System.out.println(2);
System.out.println(4.5);
System.out.println('a');
System.out.println("Hello");
System.out.println(true);
























问:内部类有独立的.class吗?----面试题
答:有











Mama$Baby.class
NstInnerClassDemo$1.class
NstInnerClassDemo$2.class
NstInnerClassDemo$3.class


字母、数字、_和$符
常量多个单词时用






1.6到1.7(内存管理差异不大)
1.7到1.8(内存管理上做了很大的改变)

final不可变的变量
static final常量











NstInnerClassDemo














InnerClassDemo











class Test{
  Aoo o1 = new Aoo(); //正确
  Boo o2 = new Boo(); //编译错误
}

class Aoo{ //外部类
  private int num = 5;
  void test(){
    Boo o = new Boo(); //正确
  }
  class Boo{ //内部类
    void show(){
	  System.out.println(num); //正确
	  System.out.println(Aoo.this.num); //正确
	  System.out.println(this.num); //编译错误
	}
  }
}









农行ATM系统:
1)所有卡都能插
2)只有农行卡才能支付电话费


ABCATM atm = new ABCATM(); //atm机对象
UnionPay card = new ABCImpl();
atm.insertCard(card);
atm.payTelBill();

class ABCATM{ //农行ATM机
  private UnionPay card; //银联卡
  public void insertCard(UnionPay card){ //插卡
    this.card = card;
  }
  public void payTelBill(){ //按钮
    if(card instanceof ABC){ //是农行卡
	  ABC abcCard = (ABC)card;
	  abcCard.payTelBill("12345679845",500);
	}else{
	  System.out.println("不是农行卡，不能支付电话费");
	}
  }
}














MultiTypeDemo


Aoo o1 = new Boo(); //向上造型
Boo o2 = (Boo)o1; //符合条件1
Inter1 o3 = (Inter1)o1; //符合条件2
//Coo o4 = (Coo)o1; //ClassCastException类型转换异常

if(o1 instanceof Coo){ //false
  Coo o5 = (Coo)o1;
}

System.out.println(o1 instanceof Boo); //true
System.out.println(o1 instanceof Inter1); //true
System.out.println(o1 instanceof Coo); //false


interface Inter1{
}
class Aoo{
}
class Boo extends Aoo implements Inter1{
}
class Coo extends Aoo{
}















父类大，子类小

Person o1 = new Student(); //向上造型(自动类型转换)


Student o2 = new Person(); //编译错误













造型之后，能点出来的东西，----多了还是少了
                           ----少了





我 me = new 我();
讲师       o1 = me; //向上造型
孩子他妈   o2 = me;
老公的老婆 o3 = me;

o1.讲课();
o2.揍他();
o3.咬他();
o3.收工资();

me.讲课();
me.揍他();
me.咬他();
me.收工资();


interface 讲师{
  void 讲课();
}
interface 孩子他妈{
  void 揍他();
}
interface 老公的老婆{
  void 咬他();
  void 收工资();
}
class 我 implements 讲师,孩子他妈,老公的老婆{
  public void 讲课(){}
  public void 揍他(){}
  public void 咬他(){}
  public void 收工资(){}
}
















动物 o1 = new 鸟();
动物 o2 = new 鱼();
动物 o3 = new 老虎();

o1.run(); //天
o2.run(); //水
o3.run(); //地


abstract class 动物{
  abstract void run();
}
class 鸟 extends 动物{
  void run(){在天上飞}
}
class 鱼 extends 动物{
  void run(){在水里游}
}
class 老虎 extends 动物{
  void run(){在地上跑}
}













人 p1 = new 理发师();
人 p2 = new 外科医生();
人 p3 = new 演员();

p1.cut(); //剪发
p2.cut(); //开刀
p3.cut(); //停止表演




abstract class 人{
  abstract void cut();
}
class 理发师 extends 人{
  void cut(){剪发}
}
class 外科医师 extends 人{
  void cut(){开刀}
}
class 演员 extends 人{
  void cut(){停止表演}
}


























需求:
  达内教学副总裁
      培训员工()、解决问题()、编辑稿件()
  达内讲师
      培训员工()、解决问题()、编辑稿件()
  达内项目经理
      编辑稿件()


abstract class 达内职员{
  姓名、年龄、工资
  void 上班打卡(){ 按个手纹、拍个照 }
  void 下班打卡(){ 按个手纹、拍个照 }
  abstract void 完成工作();
}
interface 企业技术顾问{
  培训员工()、解决问题()
}
interface 技术图书作者{
  编辑稿件()
}
class 达内教学副总裁 extends 达内职员 implements 企业技术顾问,技术图书作者{
}
class 达内讲师 extends 达内职员 implements 企业技术顾问,技术图书作者{
}
class 达内项目经理 extends 达内职员 implements 技术图书作者{
}
class 达内班主任  extends 达内职员{
}











interface CCB extends UnionPay{
  public boolean payFire(double sum);
}
class CCBImpl implements CCB{
  重写4个
}



class Six extends Shape{
  public Six(double c){
    this.c = c;
  }
  public double area(){
    return 0.0721*c*c;
  }
}










