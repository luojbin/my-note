回顾:
1.方法的重载(overload):
  1)发生在同一个类中，方法名称相同，参数列表不同
  2)编译器在编译时会根据方法的签名自动绑定方法
2.构造方法:构造器，构建器，构造函数
  1)给成员变量赋初值
  2)与类同名，没有返回值类型
  3)在创建对象时被自动调用
  4)若自己不写构造，则默认无参构造，
    若自己写了，则不再默认提供
  5)可以重载
3.this:指代当前对象，哪个对象调方法指的就是哪个对象
       只能用在方法中，在方法中访问成员变量之前默认有个this.
  this用法:
    1)this.成员变量名-----------访问成员变量
	2)this.方法名()-------------调用方法
	3)this()--------------------调用构造方法





笔记:
1.引用类型数组:
  1)Cell[] cells = new Cell[4];
    cells[0] = new Cell(2,5);
	cells[1] = new Cell(2,6);
	cells[2] = new Cell(2,7);
	cells[3] = new Cell(2,8);
  2)Cell[] cells = new Cell[]{
      new Cell(2,5),
	  new Cell(2,6),
	  new Cell(2,7),
	  new Cell(3,6)
    }; 
  3)int[][] arr = new int[3][];
    arr[0] = new int[2];
	arr[1] = new int[3];
	arr[2] = new int[2];
    arr[1][0] = 100; //给arr中第2个元素中的第1个元素赋值为100
  4)int[][] arr = new int[3][4];
    for(int i=0;i<arr.length;i++){ //行
	  for(int j=0;j<arr[i].length;j++){ //列
	    arr[i][j] = 100;
	  }
	}
2.继承:
  1)作用:实现代码的复用、避免代码重复
  2)通过extends来实现继承
  3)父类/基类:所有子类所共有的属性和行为
    子类/派生类:子类所特有的属性和行为
  4)子类继承父类后，子类具有:父类的+子类的
  5)一个父类可以有多个子类
    一个子类只能继承一个父类----单一继承
  6)继承具有传递性
  7)java规定:构造子类之前必须先构造父类
    若子类自己不调父类构造，则编译器默认在子类构造的第一句通过super()调父类无参构造
	若子类自己调了父类构造，则不再默认提供
    super()调父类构造必须位于子类构造的第一行
3.super:指代当前对象的父类对象
  super的用法:
    super.成员变量名------------访问父类的成员变量
	super.方法名()--------------调用父类的方法
	super()---------------------调用父类的构造方法
4.向上造型:
  1)父类型的引用指向子类的对象
  2)能点出来什么，看引用的类型


练习:
1.练习UpDemo(向上造型的练习)
2.完成如下类:----oo.day04
  2.1)Cell类:
        row,col,Cell(int row,int col),getCellInfo()
  2.2)Tetromino类:
        cells,Tetromino(),drop(),moveLeft(),
		moveRight(),print()
  2.3)T类，继承Tetromino:
        T(),T(int row,int col)
  2.4)J类，继承Tetromino:
        J(),J(int row,int col)
  2.5)L类，继承Tetromino:
        L(),L(int row,int col)
  2.6)O类，继承Tetromino:
        O(),O(int row,int col)
  2.7)TJTest类，包含:
        main()----输出T,J,L,O四种图形
		printWall(Tetromino t)--打墙+打图形















UpDemo














假设: 有一种类型
         既能接收T型对象
		 也能接收J型对象
		 也能接收L型对象
		 也能接收O型对象
		 也能接收I型对象
		 也能接收S型对象
		 也能接收Z型对象


Tetromino o1 = new T(); //向上造型
Tetromino o2 = new J();
Tetromino o3 = new L();
Tetromino o4 = new I();
Tetromino o5 = new O();
Tetromino o6 = new S();
Tetromino o7 = new Z();












Person p1 = new Student();
Person p2 = new Teacher();
Person p3 = new Doctor();












//动物是动物
Animal o1 = new Animal();
//老虎是老虎
Tiger o2 = new Tiger();
//老虎是动物
Animal o3 = new Tiger(); //向上造型




//动物是老虎---------------语义不通
Tiger o4 = new Animal(); //编译错误




class Animal{ //动物
}
class Tiger extends Animal{ //老虎
}












继承要符合is a的关系











为何要重载?
  T型参数只能接收T型对象
  J型参数只能接收J型对象
  L型参数只能接收L型对象
  O型参数只能接收O型对象
  I型参数只能接收I型对象
  S型参数只能接收S型对象
  Z型参数只能接收Z型对象

假设: 有一种类型
         既能接收T型对象
		 也能接收J型对象
		 也能接收L型对象
		 也能接收O型对象
		 也能接收I型对象
		 也能接收S型对象
		 也能接收Z型对象













何时打*:只要行列匹配就打*
何时打-:所有格子都没匹配上则打-


判断多次才能得到最终结果-----------开关









//效率高，扩展性差
for(int i=0;i<20;i++){
	for(int j=0;j<10;j++){
		if(i==t.cells[0].row && j==t.cells[0].col
		   ||
		   i==t.cells[1].row && j==t.cells[1].col
		   ||
		   i==t.cells[2].row && j==t.cells[2].col
		   ||
		   i==t.cells[3].row && j==t.cells[3].col){
			System.out.print("* ");
		}else{
			System.out.print("- ");
		}
	}
	System.out.println();
}





产品

项目











Coo o = new Coo();
o.c = 1;
o.b = 2;
o.a = 3;



class Aoo{
  int a;
}
class Boo extends Aoo{
  int b;
}
class Coo extends Boo{
  int c;
}






Tetromino








Student zs = new Student();
zs.className/study();
zs.name/age/address/eat()/sleep();

class Person{ //父类
  String name;
  int age;
  String address;
  void eat(){}
  void sleep(){}
}

class Student extends Person{ //子类
  String className;
  void study(){}
}
class Teacher extends Person{ //子类
  double salary;
  void teach(){}
}
class Doctor extends Person{ //子类
  String level;
  void cut(){}
}















程序中的继承:
    代码不用自己写，自己也能用

生活中的继承:
1)继承财产:
    钱不用自己挣，自己也能花
2)继承皇位:
    江山不用自己打，自己也能坐
3)继承工作:
    工作不用自己找，自己也能干














1)找对象:很多个T,J,O,L,I,S,Z型的对象
2)抽类:T,J,O,L,I,S,Z
3)设计类中的成员变量和方法:
4)创建对象并测试:



T t1 = new T(); //00,01,02,11
T t2 = new T(); //00,01,02,11
T t3 = new T(); //00,01,02,11



T t1 = new T(2,5); //25,26,27,36
T t2 = new T(1,4); //14,15,16,25
T t3 = new T(0,0); //00,01,02,11
T t4 = new T();    //00,01,02,11


class T{ //T型
  Cell[] cells; //格子数组
  T(){
    this(0,0);
  }
  T(int row,int col){
    cells = new Cell[4];
	cells[0] = new Cell(row,col);
	cells[1] = new Cell(row,col+1);
	cells[2] = new Cell(row,col+2);
	cells[3] = new Cell(row+1,col+1);
  }
  void drop(){
    for(int i=0;i<cells.length;i++){
	  cells[i].row++;
	}
  }
  void moveLeft(){
    for(int i=0;i<cells.length;i++){
	  cells[i].col--;
	}
  }
  void moveRight(){
    for(int i=0;i<cells.length;i++){
	  cells[i].col++;
	}
  }
  void print(){ //输出4个格子的行号和列号
    for(int i=0;i<cells.length;i++){
	  String str = cells[i].getCellInfo();
	  System.out.println(str);
	}
  }

}






TJTest


class J{
  Cell[] cells;
  J(){
    this(0,0);
  }
  J(int row,int col){
    cells = new Cell[4];
	cells[0] = new Cell(row,col);
	cells[1] = new Cell(row+1,col);
	cells[2] = new Cell(row+2,col-1);
	cells[3] = new Cell(row+2,col);
  }
  void drop(){
    for(int i=0;i<cells.length;i++){
	  cells[i].row++;
	}
  }
  void moveLeft(){
    for(int i=0;i<cells.length;i++){
	  cells[i].col--;
	}
  }
  void moveRight(){
    for(int i=0;i<cells.length;i++){
	  cells[i].col++;
	}
  }
  void print(){ //输出4个格子的行号和列号
    for(int i=0;i<cells.length;i++){
	  String str = cells[i].getCellInfo();
	  System.out.println(str);
	}
  }
}













Cell格子的属性

















class J{
}
class L{
}
class O{
}
class I{
}
class S{
}
class Z{
}














RefArrayDemo















3为arr的长度----------------arr.length
4为arr中每个元素的长度------arr[i].length

int[][] arr = new int[3][4]; //3行4列
for(int i=0;i<arr.length;i++){
  for(int j=0;j<arr[i].length;j++){
    arr[i][j] = 100;
  }
}












i=1
  j=0 arr10
  j=1 arr11
  j=2 arr12
  j=3 arr13



















int[][] arr = new int[3][];
arr[0] = new int[4]; 
arr[1] = new int[4];
arr[2] = new int[4];




















int   [] arr   = new int[3];
Cell  [] cells = new Cell[4];



//声明int[]型数组arr，包含3个元素
//每个元素都是int[]型，默认值为null
int[][] arr = new int[3][];
arr[0] = new int[2]; 
arr[1] = new int[3];
arr[2] = new int[2];
//给arr中第2个元素中的第1个元素赋值为100
arr[1][0] = 100;


arr--------------------int[][]
arr[0]-----------------int[]
arr[0][0]--------------int










arr中包含3个元素
arr中第1个元素又包含2个int
arr中第2个元素又包含3个int
arr中第3个元素又包含2个int












arr[0]-------------为int[]型















int[] arr = new int[]{
  2,
  5,
  7,
  8
};

Cell[] cells = new Cell[]{
  new Cell(2,5),
  new Cell(2,6),
  new Cell(2,7),
  new Cell(3,6)
};













引用中装的是地址













int[] arr = new int[4];
arr[0] = 5;


Cell[] cells = new Cell[4]; //创建Cell数组对象
cells[0] = new Cell(2,5);   //创建Cell对象
cells[1] = new Cell(2,6);
cells[2] = new Cell(2,7);
cells[3] = new Cell(3,6);














//声明Cell型数组cells，包含4个元素
//每个元素都是Cell型，默认值为null
Cell[] cells = new Cell[4];



//声明Student数组stus，包含10个元素
//每个元素都是Student型，默认值为null
Student[] stus = new Student[10];
stus[0] = new Student("zhangsan",25,"廊坊");












//声明int型数组arr，包含3个元素
//每个元素都是int型，默认值为0
int[] arr = new int[3];



















