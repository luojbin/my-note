<!DOCTYPE html>
<html>
<head>
<title>day07</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Java API</h1>
<h2>RAF 总结</h2>
<ol>
<li>
理解什么是文件
<ul>
<li>文件是由byte组成的序列</li>
</ul>
</li>
<li>RAF可以打开文件，在文件的任意位置开始读写</li>
<li>
RAF打开文件方式：
<ul>
<li>r 只读</li>
<li>rw 读写</li>
</ul>
</li>
<li>
基本的读写方法
<ul>
<li>read()  读取一个byte</li>
<li>write() 写出一个byte</li>
<li>文件的读写位置（文件指针）会自动移动</li>
<li>每次第一个byte（0~255）</li>
</ul>
</li>
<li>
在基本读写方法之上，扩展了基本类型的读写
<ul>
<li>readInt  writeInt  每次读写4个byte</li>
<li>readLong  writeLong  每次读写8个byte</li>
<li>...</li>
</ul>
</li>
<li>
String 的读写
<ul>
<li>内存中的字符串是char数据，不是byte类型</li>
<li>
写出字符串：
<ul>
<li>需要将字符串进行编码（UTF-8）编码为byte数据</li>
<li>然后在写到文件中！！！</li>
</ul>
</li>
<li>
读取字符串
<ul>
<li>读取byte数据</li>
<li>将byte数据解码（UTF-8）为字符串！</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3>随机读写文件</h3>
<p>RAF 可以从文件的任何位置开始读写文件，其核心方法是seek(位置)：</p>
<p>案例：</p>
<pre><code>/**
 * 随机文件读写 
 *
 */
public class Demo01 {
    public static void main(String[] args) 
        throws Exception{
        String file = &quot;abc/myfile.dat&quot;;
        RandomAccessFile raf=
            new RandomAccessFile(file, &quot;rw&quot;);
        //将0~255写入到文件 myfile.dat
        for(int i=0; i&lt;=255; i++){
            raf.write(i);
        }
        //移动读写位置指针到0
        raf.seek(0);//可以在任意位置开始读写
        int b;
        //经典的模式写法：
        while((b=raf.read())!=-1){
            System.out.println(b);
        }
        raf.close();
    }
}
</code></pre>

<blockquote>
<p>注意： 文件读写完毕以后才能raf.close()关闭文件！！</p>
</blockquote>
<h3>基本类型读写</h3>
<p>RAF 提供了基本类型的读写方法，基本类型的读写方法的底层是 read() write() 方法。</p>
<ul>
<li>int 拆分为 4个byte读写</li>
<li>long 拆分为 8个byte读写</li>
<li>byte 1个byte读写</li>
<li>short 拆分为 2个byte读写</li>
<li>float 拆分为 4个byte读写</li>
<li>doubel 拆分为 8个byte读写</li>
<li>boolean 1个byte读写</li>
<li>char 拆分为 2个byte读写</li>
</ul>
<p>int 的读写原理:</p>
<p><img src="3.png" /></p>
<p>案例：</p>
<pre><code>/**
 * RAF 整数数据读写，其他类型 略
 */
public class Demo02 {
    public static void main(String[] args) 
        throws Exception{
        String file = &quot;abc/integer.dat&quot;;
        RandomAccessFile raf = 
            new RandomAccessFile(file, &quot;rw&quot;);
        //将int数据126712 拆分为4个byte写到
        //文件中，文件指针连续移动4次
        raf.writeInt(126712); 
        long p = raf.getFilePointer();
        System.out.println(p);
        raf.seek(0);
        //读取一个整数: 连续读取4个byte，拼接
        // 为一个int数据, 文件指针连续移动4次
        int n = raf.readInt();
        p = raf.getFilePointer();
        System.out.println(p);//4
        System.out.println(n);//126712
        raf.close();
    }
}
</code></pre>

<h3>字符串IO</h3>
<p>字符串中存储的是char数据，不能直接IO，需要先进行编码，编码为byte数据在进行读写。常见的编码方案是 UTF-8.</p>
<p>在UTF-8 编码中：英文字符1个byte，中文字符3个byte</p>
<p>案例：</p>
<pre><code>/**
 * 字符串类型的写出和读取 
 */
public class Demo03 {
    public static void main(String[] args) 
        throws Exception{
        String file=&quot;abc/str.txt&quot;;
        RandomAccessFile raf = 
            new RandomAccessFile(file, &quot;rw&quot;);
        String str = &quot;你好ABC&quot;;
        //对字符串进行UTF-8编码
        byte[] bytes=str.getBytes(&quot;UTF-8&quot;);
        System.out.println(bytes.length);//9
        //将文字的编码写入到文件中
        raf.write(bytes);//将数组中全部的byte
        //数据写入到文件中。
        long p = raf.getFilePointer();
        System.out.println(p);//9
        //从头读取
        raf.seek(0);
        byte[] buf=new byte[(int)raf.length()];
        //read(bytes) 从文件中连续读取byte数据
        //将读取结果填充到 byte数组中
        raf.read(buf);
        //buf 中是按照UTF-8编码的字符数据,解码：
        String s = new String(buf, &quot;UTF-8&quot;);
        System.out.println(s); 
        raf.close();
    }
}
</code></pre>

<blockquote>
<p>注意：文字信息必须经过编码才能写到文件中。读取文件时候需要进行解码处理。 如果编码和解码的规则不一致就会出现乱码问题！！</p>
</blockquote>
<h3>综合案例</h3>
<p>将员工信息写到文件中，并且在读取回来：</p>
<p>原理：</p>
<p><img src="5.png" /></p>
<p>写数据案例：</p>
<pre><code>/**
 * 写员工信息 
 */
public class Demo04 {
    public static void main(String[] args) 
        throws IOException{
        String file=&quot;abc/emp.dat&quot;;
        RandomAccessFile raf=
            new RandomAccessFile(file, &quot;rw&quot;);
        write(raf, 0,&quot;Tom&quot;, 10, &quot;男&quot;, 100, new Date());
        write(raf, 1,&quot;范传奇&quot;,30,&quot;男&quot;,200,new Date());
        raf.close();
    }   
    public static void write(
            RandomAccessFile raf, //已经打开的文件
            int n, //n = 0 1 2 ... 行号
            String name, 
            int age,
            String sex,
            int salary,
            Date hiredate)throws IOException{
        int start=n*80;//n=0,0  n=1,80  n=2,160
        raf.seek(start);//将文件指针移动到每行起始位置
        //将name编码，然后写到文件中
        byte[] bytes=name.getBytes(&quot;UTF-8&quot;);
        raf.write(bytes); //3 9 10
        //写出age
        raf.seek(start+32);//跳到age位置
        raf.writeInt(age);//写出年龄
        //写出性别
        bytes = sex.getBytes(&quot;UTF-8&quot;);
        raf.write(bytes);
        //写出薪水
        raf.seek(start+46);
        raf.writeInt(salary); 
        //写出日期
        SimpleDateFormat fmt = 
                new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        String d = fmt.format(hiredate);
        bytes = d.getBytes(&quot;UTF-8&quot;);
        raf.write(bytes);
    }
}
</code></pre>

<p>读取员工信息：</p>
<pre><code>/**
 * 读取员工信息文件 
 *
 */
public class Demo05 {
    public static void main(String[] args) 
        throws  Exception {
        String file=&quot;abc/emp.dat&quot;;
        //打开文件 emp.dat
        RandomAccessFile raf=
            new RandomAccessFile(file, &quot;r&quot;);
        //读取第一行 （Tom）
        Emp e1 = read(raf, 0);
        //读取第二行 （范传奇）
        Emp e2 = read(raf, 1);
        //显示读取结果
        System.out.println(e1);
        System.out.println(e2);
        //关闭文件
        raf.close();
    }
    public static Emp read(
        RandomAccessFile raf, int n) 
        throws Exception {  
        int start = n*80;//读取的起始位置
        raf.seek(start);//找到name的起始位置
        byte[] bytes = new byte[32];
        raf.read(bytes);//读取32个byte
        //bytes=[T,o,m,0,0,0,0,0,...0]
        String name=
            new String(bytes,&quot;UTF-8&quot;).trim();
        //读取年龄
        int age = raf.readInt();
        //读取性别...
        bytes = new byte[10];
        raf.read(bytes);
        String sex=new String(bytes,&quot;UTF-8&quot;).trim();
        //读取薪水
        int salary = raf.readInt();
        //读取日期
        bytes = new byte[30];
        raf.read(bytes);
        String str = new String(bytes, &quot;UTF-8&quot;).trim();
        //解析日期
        SimpleDateFormat fmt = 
            new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date hiredate=fmt.parse(str);
        return new Emp(
            name,age,sex,salary,hiredate);
    }
}
class Emp{
    String name;
    int age;
    String sex;
    int salary;
    Date hiredate;
    public Emp(String name, int age, String sex, int salary, Date hiredate) {
        super();
        this.name = name;
        this.age = age;
        this.sex = sex;
        this.salary = salary;
        this.hiredate = hiredate;
    }
    public String toString() {
        return &quot;Emp [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex + &quot;, salary=&quot; + salary + &quot;, hiredate=&quot; + hiredate
                + &quot;]&quot;;
    }

}
</code></pre>

<h2>IO流</h2>
<p>RAF 提供了文件随机读写功能，但是没有提供复杂数据的读写功能。 Java 提供了另外一套可以灵活扩展的API： IO流。</p>
<p>IO流在节点流基础之上提供了丰富的的扩展功能，利用这些扩展流可以大大简化IO程序的开发。 </p>
<p><img src="7.png" /></p>
<p>IO流按照功能可以分为两大类： 节点流和处理流</p>
<h3>节点流</h3>
<p>节点流是流最原始的数据源，提供流最基本的功能。</p>
<h3>处理流</h3>
<p>也称为高级流，过滤流，处理流是在其他流的基础之上扩展出更高级的功能。处理流的核心特点是必须依赖于另外一个流，自己不能独立功能，处理流是对另外的流进行扩展。</p>
<h3>　输入流与输出流</h3>
<p>流按照数据流向分为输入流和输入流：</p>
<p><img src="6.png" /></p>
<ul>
<li>
InputStream 代表输入流 经常缩写为in
<ul>
<li>包含核心方法 read()</li>
<li>关闭方法 close()</li>
</ul>
</li>
<li>
OutputStream 输出流流 经常缩写为out
<ul>
<li>包含核心方法 write()</li>
<li>关闭方法 close()</li>
</ul>
</li>
</ul>
<blockquote>
<p>这两个流是抽象类，不能直接使用。在实际工作中使用其实现类</p>
</blockquote>
<h3>文件输出流 FileOutputStream</h3>
<p>文件输出流节点流，是以文件为目标数据源的节点流，是基本的流，只提供了基本的输出方法write()</p>
<p>案例：</p>
<pre><code>/**
 * 使用文件输出节点流写文件 
 */
public class Demo06 {
    public static void main(String[] args) 
        throws Exception {
        String file=&quot;abc/fos.dat&quot;;
        //利用文件节点流打开一个文件
        //当文件不存在时候，会自动创建文件
        //文件存在时候将文件替换为新文件
        //当文件不能写时候，出现异常
        FileOutputStream out = 
            new FileOutputStream(file);
        //测试基本的 byte 数据写出方法
        //将byte写到文件中有效范围（0~255）
        out.write(65);
        out.write(66);
        //关闭文件
        out.close();
    }
}
</code></pre>

<h3>文件输入流</h3>
<p>文件输入节点流，是文件作为数据来源的节点流，也是基础节点流，提供了基本的文件读取功能。</p>
<p>案例：</p>
<pre><code>/**
 * 测试 文件输入节点流 的读取文件
 */
public class Demo07 {
    public static void main(String[] args) 
        throws Exception {
        String file=&quot;abc/fos.dat&quot;;
        //用文件节点输入流打开文件
        //如果文件不能打开或者文件不存在
        //就抛出异常！
        FileInputStream in = 
            new FileInputStream(file);
        //测试基本的节点流读取方法
        //每次从文件中读取一个byte(0~255)
        int b1 = in.read();
        int b2 = in.read();
        System.out.println(b1);
        System.out.println(b2);
        in.close();
    }
}
</code></pre>

<h3>复制一个文件</h3>
<p>将文件输入流与文件输出流连接起来，就可以实现文件的复制功能：</p>
<pre><code>/**
 * 利用文件流实现文件的复制功能 
 * 
 * 在不使用缓冲流的情况下，读写性能很差！
 * 
 */
public class Demo08 {
    public static void main(String[] args) 
        throws Exception{
        //打开原始输入文件
        FileInputStream in =
            new FileInputStream(
            &quot;d:/TETRIS.zip&quot;);

        //打开目标的输出文件
        FileOutputStream out = 
            new FileOutputStream(
            &quot;d:/TETRIS_new.zip&quot;);

        //从in里读取每个byte写到out流中
        int b;
        while((b=in.read())!=-1){
            //b代表原始文件中的每个byte
            out.write(b); 
        }
        //关闭in，out即可
        in.close(); 
        out.close();
        System.out.println(&quot;成功！&quot;);
    }
}
</code></pre>

<blockquote>
<p>这个程序性能有瑕疵。</p>
</blockquote>
<p>利用缓存读写方法可以提供 文件复制性能：</p>
<pre><code>/**
 * 自定义缓存读写 
 */
public class Demo09 {
    public static void main(String[] args) 
        throws Exception{
        //打开原始输入文件
        FileInputStream in =
            new FileInputStream(
            &quot;d:/TETRIS.zip&quot;);
        //打开目标的输出文件
        FileOutputStream out = 
            new FileOutputStream(
            &quot;d:/TETRIS_new.zip&quot;);
        byte[] buf=new byte[1024*8];//1K byte
        //从输入流in中读取尽可能多的byte填充
        //到缓存 buf 中，返回读取个数 1024
        //int n = in.read(buf);//1024
        //int n = in.read(buf);//1024
        //...
        //n = in.read(buf); // 1 ~ 1024
        //n = in.read(buf); // -1
        int n;
        while((n = in.read(buf))!=-1){
            //将buf中从0开始的连续n个byte
            //写到 文件流out中
            out.write(buf, 0, n);
        }

        in.close();
        out.close();
        System.out.println(&quot;OK!&quot;);
    }
}
</code></pre>

<blockquote>
<p>为了避免最后一次复制多余的byte必须使用 out.write(buf, 0, n) 方法。</p>
</blockquote>
<h3>缓冲流</h3>
<p>Java提供了使用简便的高级扩展流： 缓冲流</p>
<ol>
<li>缓冲流必须依赖一个基础流，如：节点流</li>
<li>缓冲流可以在不改变原有算法逻辑情况下，为流提供缓冲区，可以加快系统IO性能。</li>
</ol>
<p>如：</p>
<pre><code>/**
 * 利用文件流实现文件的复制功能 
 * 
 * 在不使用缓冲流的情况下，读写性能很差！
 * 
 */
public class Demo08 {
    public static void main(String[] args) 
        throws Exception{
        //打开原始输入文件
        FileInputStream fis =
            new FileInputStream(
            &quot;d:/TETRIS.zip&quot;);

        BufferedInputStream in =
            new BufferedInputStream(fis);

        //打开目标的输出文件
        FileOutputStream fos = 
            new FileOutputStream(
            &quot;d:/TETRIS_new.zip&quot;);

        BufferedOutputStream out=
            new BufferedOutputStream(fos); 


        //从in里读取每个byte写到out流中
        int b;
        while((b=in.read())!=-1){
            //b代表原始文件中的每个byte
            out.write(b); 
        }
        //关闭in，out即可
        in.close(); 
        out.close();
        System.out.println(&quot;成功！&quot;);
    }
}
</code></pre>

<blockquote>
<p>可以看到，复制文件的算法没有改变，只是在原有文件流的外部&quot;套上&quot;缓冲流，软件的IO性能就大大加快了。</p>
</blockquote>
<hr />
<h2>作业</h2>
<ol>
<li>完成课堂案例</li>
<li>完成SVN中的作业</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
