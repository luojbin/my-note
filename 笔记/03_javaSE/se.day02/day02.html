<!DOCTYPE html>
<html>
<head>
<title>day02</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>Java API</h1>
<h2>String 和 StringBuilder</h2>
<p>String是不变字符串： 对象不可改变，对象中的字符数组中的数据不可改变。</p>
<p>StringBuilder是可变字符串：对象封装的字符数组中的数据可以改变。</p>
<p>StringBuilder类型的操作性能好于Srting，字符串操作建议使用StringBuilder。 字符串显示使用String。</p>
<p>运行期间字符串连接计算利用StringBuilder的append完成。</p>
<p>案例：</p>
<pre><code>String s = &quot;123&quot;;
String ss = s + &quot;abc&quot;;
//ss = new StringBuilder(s)
//      .append(&quot;abc&quot;).toString();
</code></pre>

<p>案例：</p>
<pre><code>String s = &quot;123&quot;+&quot;456&quot;+&quot;abc&quot;;
String ss = &quot;123&quot;;
String str = ss + &quot;456&quot;+&quot;abc&quot;;
//在一个表达式中出现连续的字符串连接，Java会
//自动的优化为一个StringBuilder对象
//String str = new StringBuilder(ss)
//  .append(&quot;456&quot;).append(&quot;abc&quot;).toString();
</code></pre>

<blockquote>
<p>在工作中一个表达式中的连续字符串连接不需要优化为StringBuilder</p>
<p>在反复进行字符串连接时候建议使用StringBuilder</p>
</blockquote>
<h2>正则表达式</h2>
<p>用于声明字符串的规则表达式。</p>
<p>经常用于检测一个字符串是否符合特定规则。</p>
<p>语法：</p>
<ol>
<li>
字符集合：
<ul>
<li>[abcd] abcd四个字符选一个</li>
<li>[a-f]  a到f字符选一个</li>
<li>[^abcd] 除了abcd字符的其他字符</li>
<li>
缩写版
<ul>
<li>. 任意字符</li>
<li>\d 数字</li>
<li>\D 非数字</li>
<li>\w 单词字符</li>
<li>\W 非单词字符</li>
<li>\s 空白</li>
<li>\S 非空白</li>
</ul>
</li>
</ul>
</li>
<li>
数量词
<ul>
<li>X{n} n个X</li>
<li>X{n,m} n到m个</li>
<li>X{n, } 最少n个</li>
<li>? {0,1}</li>
<li>* {0,}</li>
<li>+ {1,}</li>
</ul>
</li>
<li>
分组
<ul>
<li>(序列1|序列2)</li>
</ul>
</li>
</ol>
<p>常见案例：</p>
<pre><code>邮政编码的规则 \d{6}
身份证的规则 d{17}[\dXx]
用户名的规则: 8到11个单词字符 \w{8,11}
检查一个文件是否为jpeg照片文件： .+\.jpe?g
检查一个文件是否为照片文件： .+\.(jpe?g|png|gif)
Excel能够支持的文件名规则 ： .+\.xls[xbm]?
手机号的规则： (0086|\+86)?\s*1\d{10}
</code></pre>

<h2>String 正则API</h2>
<h3>matches</h3>
<p>用于检测一个字符串整体是否符合指定的正则规则。</p>
<p>案例：</p>
<pre><code>//String reg=&quot;.+\\.jpe?g&quot;;
String reg=&quot;.+\\.(jpe?g|png|gif)&quot;;
//正则表达式： .+\.(jpe?g|png|gif)
//Java 字符串: .+\\.(jpe?g|png|gif)
String file = &quot;她.png&quot;;
System.out.println(reg); 
boolean b = file.matches(reg);
System.out.println(b);  
</code></pre>

<h3>split</h3>
<p>按照一定规则将字符串劈开</p>
<pre><code>String str=
    &quot;1, 李洪鹤, 110, lihh@tedu.cn, 北京海淀区&quot;;
String[] data=str.split(&quot;,\\s*&quot;);
// &quot;1&quot;, &quot;李洪鹤&quot; ...
System.out.println(data[1]);
</code></pre>

<h3>replaceAll</h3>
<p>replace 替换</p>
<pre><code>String str = &quot;那一年，我去你家，你说我去！&quot;
String reg = &quot;我去&quot;;
String s = str.replaceAll(reg, &quot;XXX&quot;);
System.out.println(s);
</code></pre>

<h2>Object 类</h2>
<ul>
<li>在Java类继承结构中，java.lang.Object类位于顶端；</li>
<li>如果定义一个Java类时没有使用extends关键字声明其父类，则其父类默认为 java.lang.Object 类；</li>
<li>Object类型的引用变量可以指向任何类型对象。</li>
<li>
Java 设计者将子类中必须有的方法都定义在Object类中
<ul>
<li>toString</li>
<li>equals</li>
</ul>
</li>
</ul>
<h3>toString方法</h3>
<p>关于Object 的toString方法：</p>
<ol>
<li>返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。</li>
<li>建议所有子类都重写此方法。</li>
<li>
Object默认的toString方法返回值是
<ul>
<li>类名@散列码</li>
<li>这个默认方法是没有实际意义的结果，所以建议重写此方法。</li>
</ul>
</li>
<li>
由于很多Java API会自动调用toStirng方法，所以重写toString方法可以简化软件的开发调试。
<ul>
<li>重写时候一般返回对象关键数据。</li>
</ul>
</li>
</ol>
<p>案例重写toString方法：</p>
<pre><code>public class Demo11 {
    public static void main(String[] args) {
        Foo foo = new Foo();
        //调用Object提供的默认toString方法
        //返回一个字符串，意义不大
        String str = foo.toString();
        System.out.println(str);
        //调用重写的toString()方法
        Goo goo = new Goo();
        String s = goo.toString();
        System.out.println(s);
        //toString的用途：println 等
        //很多API会自动的调用toString
        //可以简化软件的开发和测试
        System.out.println(goo); 
    }
}
class Foo /*extends Object*/{
}
class Goo{
    //重新继承与Object类的toString();
    public String toString(){
        return &quot;Hello World!&quot;;
    }
}
</code></pre>

<p>案例, 一个有意义的toString重写：</p>
<pre><code>/**
 * 一个有意义的toString重写案例 
 */
public class Demo12 {
    public static void main(String[] args) {
        Airplane a1 = new Airplane(5, 7);
        a1.move();
        a1.move();
        a1.move();
        //System.out.println(a1.x+&quot;,&quot;+a1.y);
        System.out.println(a1);
        a1.move();
        a1.move();
        a1.move();
        //System.out.println(a1.x+&quot;,&quot;+a1.y);
        System.out.println(a1);
    }
}
class Airplane{
    int x, y;
    public Airplane(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public void move(){
        x++;
        y+=2;
    }
    //重写toString方法后可以简化调试程序
    //在程序中使用 System.out.println(plane);
    //即可输出对象的数据值
    public String toString() {
        return x+&quot;,&quot;+y;
    }
}
</code></pre>

<h3>equals</h3>
<ol>
<li>== 不能比较两个对象是否相等</li>
<li>
Java 在Object提供了equals方法，用于比较两个对象是否相等
<ul>
<li>equals默认的方法还是采用 == 比较，默认方法方法不能用于比较两个对象是否相等。</li>
<li>Java建议重写equals方法实现对象的相等比较</li>
</ul>
</li>
<li>如何重写？按照对象的关键属性比较两个对象是否相等。</li>
<li>
<p>重写模板：</p>
<pre><code>public boolean equals(Object obj){
    //当两个对象的x和y都相等时候则相等
    if(obj==null) return false;
    if(this==obj) return true;
    //使用if语句保护，避免造型异常
    if(obj instanceof PointX){
        //为了读取x y属性必须造型为子类型
        PointX other=(PointX)obj;
        return this.x == other.x &amp;&amp; 
            this.y == other.y;
    }
    //方法一定返回一个boolean值！
    return false;
}
</code></pre>

</li>
</ol>
<p>==不能用于比较对象：</p>
<p><img src="point.png" /></p>
<p>案例：</p>
<pre><code>/**
 * 测试 重写 equals 方法 
 *
 */
public class Demo13 {
    public static void main(String[] args) {
        Point p1 = new Point(3, 4);
        Point p2 = new Point(5, 6);
        Point p3 = new Point(3, 4);
        Point p4 = p1;
        //p1和p3引用的对象逻辑上是相等的！
        //但是==比较不能反映这个“相等”结果
        //== 只能用于比较两个变量相等
        //不能用于比较两个对象是否相等
        System.out.println(p1==p3);//false
        System.out.println(p1==p4);//true

        //默认的equals方法也不能对象相等
        //必须重新才行！！！
        System.out.println(p1.equals(p3));
        System.out.println(p1.equals(p4));

        PointX p5 = new PointX(3, 4);
        PointX p6 = new PointX(3, 4);

        System.out.println(p5.equals(p6));//true 
        System.out.println(p5.equals(null)); 
    }
}
class Point{
    int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public String toString() {
        return x+&quot;,&quot;+y;
    }
}
class PointX{
    int x, y;
    public PointX(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public String toString() {
        return x+&quot;,&quot;+y;
    }
    //重写equals方法比较两个对象是否相等
    public boolean equals(Object obj){
        //当两个对象的x和y都相等时候则相等
        if(obj==null) return false;
        if(this==obj) return true;
        //使用if语句保护，避免造型异常
        if(obj instanceof PointX){
            //为了读取x y属性必须造型为子类型
            PointX other=(PointX)obj;
            return this.x == other.x &amp;&amp; 
                this.y == other.y;
        }
        //方法一定返回一个boolean值！
        return false;
    }
}
</code></pre>

<hr />
<h1>作业</h1>
<p>请从SVN下载作业</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
