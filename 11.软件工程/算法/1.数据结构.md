# █ 数据结构基础

# 表, 队列, 栈

## 表 list

将一系列元素依次排列,  形如{A~0~, A~1~, A~2~…A~n-1~} 的数据结构, 称为**表**, 且将表内元素个数称为**表的大小**

表的基本操作

- 添加 `insert`
- 删除 `remove`
- 查找 `findKth`

### 数组 ArrayList

可以用数组来实现表, 适合顺序插入+随机获取的场景, 

在数组中, 可以通过数组下标, 在常数时间内定位到指定位置的元素`O(1)`, 适合频繁随机获取元素的场景

但是, 不适合频繁进行随机位置的插入或删除的操作`O(N)`, 需要移动大量的元素

### 链表 LinkedList

如果需要频繁对表进行随机插入或删除, 则使用链表更加合适. 

链表由一系列节点组成, 每个节点包括2部分

- 当前节点的数据
- 下一节点的位置

当需要在表中插入或删除一个元素时, 只需要修改上一节点中维护的下一节点位置即可, 该操作可以在常数时间内完成 `O(1)`

但是, 如果需要获取某个位置的元素时, 需要从链表开头通过一个个元素遍历过去, `O(N)`, 效率较低

#### 单链表

#### 双链表

为了提高逆向获取元素的速度, 对单链表进行改造, 每个节点除了下一节点的位置, 也同时记录了上一节点的位置, 这种链表就可以在正反两个方向进行遍历, 改善了访问效率

## 队列 queue

队列是一种特殊的表, 只允许在表的一端进行添加, 另一端进行删除, 先进先出, FIFO

基本操作

- 入队 `enqueue`
- 离队 `dequeue`

队列的应用

多任务排队执行

但应注意, 完全按先到先得的原则让任务进行排队可能是不合适的, 小任务可能会等待太长的时间. 为了提高效率, 多任务调度应该考虑优先完成简单的小任务, 具体的优先调度原则后面再看

## 栈 stack

栈也是一种特殊的表, 比队列更加严格, 只允许在一个位置上进行添加/删除操作, 后进先出, LIFO

- 压栈 `push`
- 弹栈 `pop`
- 查看栈顶 `peek`/`top`

由于栈只能在表的一个端点上操作, 而不论数组表还是链表, 都能在常数时间内完成对端点的操作

- 链表实现, 只需要栈顶到下一层元素位置即可, 因此可用单链表实现
- 数组实现, 而数组实现可能更加简单, 只需要在数组的基础上维护一个栈顶位置即可, array[top] 即可定位栈顶

### 栈的应用

平衡符号, 检查成对的符号是否正确

后缀表达式, 逆波兰算法, 可以缓存中间结果

中缀到后缀的转换, 将人们常用的算式表达式, 转换成便于计算机处理的后缀表达式

方法调用, 记录程序的执行调用过程



# 树 Tree

对于大量的输入数据, 表的线性访问时间太慢, 而树这种结构, 其大部分操作的运行时间平均为 O(logN)

## 定义

- 一棵树是一些节点的集合, 可以为空, 一棵树由 N 个节点和 N-1 条边组成
- 若不是空集, 则树由一个**根**节点R +若干个非空**子树**组成, 每一棵子树的根r, 都被来自根R 的一条有向**边**所连接
- 每一个子树的根r, 是根R 的儿子; 而根R 是子树的根r的父亲
- 儿子, 父亲, 兄弟, 孙子, 祖父, 祖先, 真祖先, 后裔, 真后裔
- 叶子节点
- 路径, 从节点 n~1~ 到 节点 n~2~ 经过的节点序列
- 长: 路径经过的边的数量
- 高: 某节点到叶子节点的最长的路径长
- 深度: 从根节点到某节点的路径长

## 树的实现

树的一种实现: 每一个节点除了数据之外, 还有一些指向其他节点的链(不一定是树的边)

```java
class TreeNode {
    Object data;			// 数据
    TreeNode firstChild;	// 指向第一个子节点的链
    TreeNode nextSibling;	// 指向下一个兄弟节点的链, 根节点没有兄弟节点
}
```

## 树的遍历

          1
        /    \
      2        3
     / \      / \
    4   5    6   7

### 广度优先遍历(BFS)

也称为层序遍历(level order), 先遍历完上一层的所有节点, 再遍历下一层次的节点

1, 2, 3, 4, 5, 6, 7

### 深度优先遍历(BFS)

按子树进行遍历, 遍历完一棵子树, 再遍历另一棵子树, 按照子树与父节点的遍历顺序, 可以分为三种

```shell
# 先序遍历(中, 左, 右)
1,2,3,4,3,6,7

# 中序遍历(左, 中, 右)
4,2,5,1,6,3,7

# 后序遍历(左, 右, 中)
4,5,2,6,7,3,1
```

## 二叉树

二叉树是一种特殊的树, 其中每个节点最多有2个子节点, 可以直接存储指向左右子节点的链

```java
class BinaryTreeNode {
    Object data;			// 数据
    BinaryTreeNode leftChild;	// 指向左子节点的链
    BinaryTreeNode rightChild;	// 指向右子节点的链
}
```

一棵平均二叉树的深度要比节点数N小得多, 平均深度`O(√N)`

而特殊的二叉树, 二叉查找树, 其深度的平均值为`O(logN)`

- 满二叉树, 每个节点, 要么是叶子节点, 要么有两个子树
- 完美二叉树, 在不新增层级的前提下, 无法继续添加节点的二叉树
- 完全二叉树, 完美二叉树去掉最下一层的右侧若干个节点的二叉树, 国内也称满二叉树

### 二叉查找树

二叉树的一个重要应用场景是在查找中使用, 要求**节点可排序(comparable), 且左子树<父节点<右子树**

这意味着对二叉查找树进行中序遍历, 即可得到树中元素的升序排列.

通常, 对二叉查找树的操作都需要借助递归来实现, 但因为其深度的平均值为`O(logN)`, 一般不会出现栈溢出的问题.

#### 二叉查找树的操作

- 包含 `contains`
- 最大值 `findMax`
- 最小值 `findMin`
- 插入 `insert`
- 删除 `remove`
  - 叶子节点, 直接删除
  - 单棵子树, 使父节点跳过当前节点, 直接指向子节点
  - 两棵子树, 使用右子树的最小值来替代
- 懒惰删除, 保留节点只标记删除, 适合很少删除节点的场景, 避免了对树的频繁调整

### 平衡二叉树

在二叉查找树的基础上, 进行平衡, 所有节点的左右子树的高度相等.

平衡条件过于严格, 实际上只有满二叉树(2^N^-1个节点)才能满足, 实际上无法使用

### AVL 树

在平衡二叉树的基础上, 放宽平衡条件, 左子树与右子树的高度差不超过1

### AVL 树的平衡

#### 单旋转

#### 双旋转



### B+树

多路查找树, 可以快速降低树的层数, 从而减少查询次数, 主要用于磁盘文件系统的寻址, 减少磁盘读写次数

规则

- 数据项都存储在叶子节点上
- 非叶子节点最多存储 M-1 个关键字, 拥有 M 个子树, 第 i 个关键字代表第 i+1 个子树中最小的关键字, 即关键字是分界点
- 树根要么是一个叶子节点, 要么至少有 2 个子树(除非整棵树不足L条记录)
- 除树根外的其他非叶子节点, 拥有 M/2 ~ M 个子树
- 所有的叶子节点都在相同的深度, 并拥有 L/2 ~ L 条数据记录(除非整棵树不足L条记录)

其中, M与L 的意思如下

- M: 非叶子节点的最大子树个数, 同时是关键字个数+1
- L: 每个叶子节点的容量, 能存储几条数据记录

在文件系统中, 通常以一个磁盘区块作为一个节点, 

- 为了保证每个节点的 M L 一致, 要求每条数据记录定长? 
- 在 MySql 中, varchar / text 等内容使用引用方式存储?  
- 如果修改了表的字段树, 添加了字段, 导致每条记录的长度修改, 需要重排整个 B+ 树? 

2-3 树

红黑树

# 散列 hash

# 优先队列(堆) heap