# 三. 常见算法

## 0.递归

编写递归方法时, 应注意以下几点

1. 基准情形, 必须提供基准情形, 能直接得到结果, 不需要往下递归
2. 不断推进, 对于需要进行递归的情形, 每一次递归都要朝着一种基准情形推进
3. 设计法则, 假设所有递归调用都能运行
4. **合成效益法则**, 求解一个问题的同一实例时, 尽量不在不同的递归层数中做相同的工作

*合成效益法则, 是避免重复工作, 提升循环/递归算法效率的一个关键.*

```
举例来说, 对数列 An = n, 求前n项和Sn的数列时, 可能会有这种做法
S1 = 1;
S2 = 1+2;
S3 = 1+2+3;
...
每次计算 Sn 时, 都重复计算了前面n-1项的和, 根据合成效益法则, 我们应该避免这种重复操作, 可以直接使用前一个结果, 即
S1 = 1;
S2 = S1 + 2;
S3 = S2 + 3;
...
```

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [21. Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/) | 🟢简单 |
|                                                              |       |
|                                                              |       |
|                                                              |       |

## 1. 数组排序

![img](3.常用算法.assets/sort.png)

### 基于比较的排序

#### 冒泡排序

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![](3.常用算法.assets/bubbleSort.gif)

```java
public void selectionSort(int[] array) {
  int n = array.length;
  for (int i = 0; i < n; i++) {
    boolean flag = true;
    for (int j = 0; j < n - i - 1; j++) {
      // 遍历未排序的部分, 比较相邻两个元素的大小, 一轮遍历会将最大的元素移动到最后面
      if (array[j] > array[j + 1]) {
        // 若当前元素大于前一元素, 交换
        int t = array[j];
        array[j] = array[j + 1];
        array[j + 1] = t;
        flag = false;
      }
    }
    // 若遍历一遍未发生交换, 则已经是有序的, 不再进行无意义的比较
    if (flag) {
      break;
    }
  }
}
```

#### 选择排序

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

![](3.常用算法.assets/selectionSort-20220407222903908-9341746.gif)

```java
public void selectionSort(int[] array) {
  int n = array.length;
  for (int i = 0; i < n-1; i++) {
    int minIdx = i;
    for (int j = i + 1; j < n; j++) {
      if (array[j] < array[minIdx]) {
        // 若新元素更小, 记录最小元素下标
        minIdx = j;
      }
    }
    // 若当前元素不是最小元素, 交换
    if (minIdx != i) {
      int t = array[minIdx];
      array[minIdx] = array[i];
      array[i] = t;
    }
  }
}
```

#### 插入排序

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![](3.常用算法.assets/insertionSort.gif)

```java
public void insertionSort(int[] array) {
  int n = array.length;
  // i = 有序序列的长度
  for (int i = 1; i < n; i++) {
    // 记录当前要操作的数
    int j = i;
    int tmp = array[j];
    // 当 tmp 比前一元素小时, 将该元素往后移动一格(相当于与tmp交换位置)
    while(j > 0 && tmp < array[j - 1]){
      array[j] = array[j - 1];
      // 相当于tmp的位置前移
      j--;
    }
    // 若当前元素不是最小元素, 交换
    if (j != i) {
      array[j] = tmp;
    }
  }
}
```

#### 希尔排序



![](3.常用算法.assets/Sorting_shellsort_anim.gif)

#### 堆排序

![](3.常用算法.assets/heapSort.gif)

![](3.常用算法.assets/Sorting_heapsort_anim.gif)

#### 归并排序

![](3.常用算法.assets/mergeSort.gif)

#### 快速排序

![](3.常用算法.assets/quickSort.gif)

### 线性时间的排序

#### 桶排序

#### 基数排序

### 外部排序

## 2. 滑动窗口

### 概述

滑动窗口类型的题目经常是用来执行数组或是链表上某个区间（窗口）上的操作。比如找最长的全为1的子数组长度。滑动窗口一般从第一个元素开始，一直往右边一个一个元素挪动。当然了，根据题目要求，我们可能有固定窗口大小的情况，也有窗口的大小变化的情况。

![img](3.常用算法.assets/v2-ec5aa95052f81e22fed272c87c423653_hd.jpg)

该图中，我们的窗子不断往右一格一个移动

#### 代码结构

```java
/* 
以力扣 209 为例
给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 
*/
public int minSubArrayLen(int target, int[] nums) {
  int n = nums.length;
  if (n == 0) {
    return 0;
  }
  int ans = Integer.MAX_VALUE;
  // 判断条件
  int sum = 0;
  // 初始化窗口两端点, 都是数组起点
  int start = 0, end = 0;
  // 外层循环, 逐渐右移end
  while (end < n) {
    sum += nums[end];
    // 内层循环, 若满足条件, 尝试缩短子数组, start右移
    while (sum >= target) {
   		// 记录结果
      ans = Math.min(ans, end - start + 1);
      // 更新判断条件
      sum -= nums[start];
      start++;
    }
    // start不能继续右移, 则继续右移end
    end++;
  }
  return ans == Integer.MAX_VALUE ? 0 : ans;
}

```



下面**是一些我们用来判断我们可能需要上滑动窗口策略的方法**：

### 适用场景

这个问题的输入是一些线性结构：比如链表呀，数组啊，字符串啊之类的让你去求最长/最短子字符串或是某些特定的长度要求

### 经典题目

1. Maximum Sum Subarray of Size K (easy) 1708
2. Smallest Subarray with a given sum (easy)
3. Longest Substring with K Distinct Characters (medium)
4. Fruits into Baskets (medium)
5. No-repeat Substring (hard)
6. Longest Substring with Same Letters after Replacement (hard)
7. Longest Subarray with Ones after Replacement (hard)

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [3.Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) | 🟡中等 |
| [26.Remove Duplicates from Sorted Array](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) | 🟢简单 |
| [209.Minimum Size Subarray Sum](https://leetcode-cn.com/problems/minimum-size-subarray-sum/) | 🟡中等 |
| [567.Permutation in String](https://leetcode-cn.com/problems/permutation-in-string/) | 🟡中等 |



## 3. 双指针

### 概述

双指针是这样的模式：两个指针朝着左右方向移动（双指针分为同向双指针和异向双指针），直到他们有一个或是两个都满足某种条件。双指针通常用在排好序的数组或是链表中寻找对子。比如，你需要去比较数组中每个元素和其他元素的关系时，你就需要用到双指针了。我们需要双指针的原因是：如果你只用一个指针的话，你得来回跑才能在数组中找到你需要的答案。这一个指针来来回回的过程就很耗时和浪费空间了 — 这是考虑算法的复杂度分析的时候的重要概念。虽然brute  force一个指针的解法可能会奏效，但时间复杂度一般会是O(n²)。在很多情况下，双指针能帮助我们找到空间或是时间复杂度更低的解。

![img](3.常用算法.assets/v2-961e3bfeff0b5f3323956b4198c2811b_hd.jpg)

上图是说，我们在排好序的数组里面找是否有一对数加起来刚好等于目标和

### 适用场景

识别使用双指针的招数：

一般来说，数组或是链表是排好序的，你得在里头找一些组合满足某种限制条件

这种组合可能是一对数，三个数，或是一个子数组

### 经典题目

1. Pair with Target Sum (easy) 1865
2. Remove Duplicates (easy)
3. Squaring a Sorted Array (easy)
4. Triplet Sum to Zero (medium)
5. Triplet Sum Close to Target (medium)
6. Triplets with Smaller Sum (medium)
7. Subarrays with Product Less than a Target (medium)
8. Dutch National Flag Problem (medium)

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [19. Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) | 🟡中等 |
| [167. Two Sum II - Input Array Is Sorted](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/) | 🟡中等 |
| [189. Rotate Array](https://leetcode-cn.com/problems/rotate-array/) | 🟡中等 |
| [283. Move Zeroes](https://leetcode-cn.com/problems/move-zeroes/) | 🟢简单 |
| [344. Reverse String](https://leetcode-cn.com/problems/reverse-string/) | 🟢简单 |
| [557. Reverse Words in a String III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/) | 🟢简单 |
| [876. Middle of the Linked List](https://leetcode-cn.com/problems/middle-of-the-linked-list/) | 🟢简单 |
| [977. Squares of a Sorted Array](https://leetcode-cn.com/problems/squares-of-a-sorted-array/) | 🟢简单 |



## 4. 快慢指针

### 概述

这种模式，有一个非常出门的名字，叫龟兔赛跑。咱们肯定都知道龟兔赛跑啦。但还是再解释一下快慢指针：这种算法的两个指针的在数组上（或是链表上，序列上）的移动速度不一样。还别说，**这种方法在解决有环的链表和数组时特别有用**。

**通过控制指针不同的移动速度（比如在环形链表上），这种算法证明了他们肯定会相遇的。快的一个指针肯定会追上慢的一个（可以想象成跑道上面跑得快的人套圈跑得慢的人）。**

**![img](3.常用算法.assets/v2-2a365e4768a0ed84683257d2364a6e71_hd.jpg)**

上面这个图演示了快慢两个指针最终在5相遇了

### 适用场景

咋知道需要用快慢指针模式勒？

1. 问题需要处理**环**上的问题，比如环形链表和环形数组
2. 当你需要知道链表的长度或是某个特别位置的信息的时候

那啥时候用快慢指针而不是上面的双指针呢？

有些情形下，咱们不应该用双指针，比如我们在单链表上不能往回移动的时候。一个典型的需要用到快慢指针的模式的是当你需要去判断一个链表是否是回文的时候。

### 经典题目

1. LinkedList Cycle (easy)
2. Start of LinkedList Cycle (medium)
3. Happy Number (medium)
4. Middle of the LinkedList (easy)

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [876. Middle of the Linked List](https://leetcode-cn.com/problems/middle-of-the-linked-list/) | 🟢简单 |
|                                                              |       |



## 5. 区间合并类型

区间合并模式是一个用来处理有区间重叠的很高效的技术。在设计到区间的很多问题中，通常咱们需要要么判断是否有重叠，要么合并区间，如果他们重叠的话。这个模式是这么起作用的：给两个区间，一个是a，另外一个是b。别小看就两个区间，他们之间的关系能跑出来6种情况。详细的就看图啦。

![img](3.常用算法.assets/v2-603053309be9d035b3c8ccee773e46e7_hd.jpg)



理解和识别这六种情况，灰常重要。因为这能帮你解决一大堆问题。这些问题从插入区间到优化区间合并都有。怎么识别啥时候用合并区间模式呀？

- 当你需要产生一堆相互之间没有交集的区间的时候
- 当你听到重叠区间的时候

### 经典题目

1. Merge Intervals (medium)
2. Insert Interval (medium)
3. Intervals Intersection (medium)
4. Conflicting Appointments (medium)

## 6. 循环排序

这种模式讲述的是一直很好玩的方法：可以用来处理数组中的数值限定在一定的区间的问题。这种模式一个个遍历数组中的元素，如果当前这个数它不在其应该在的位置的话，咱们就把它和它应该在的那个位置上的数交换一下。你可以尝试将该数放到其正确的位置上，但这复杂度就会是O(n^2)。这样的话，可能就不是最优解了。因此循环排序的优势就体现出来了。

![img](3.常用算法.assets/v2-e5a2fe3faa0b55ad5c6d8f182039cd35_hd.jpg)

咋鉴别这种模式？

- 这些问题一般设计到排序好的数组，而且数值一般满足于一定的区间
- 如果问题让你需要在排好序/翻转过的数组中，寻找丢失的/重复的/最小的元素

### 经典题目

1. Cyclic Sort (easy)
2. Find the Missing Number (easy)
3. Find all Missing Numbers (easy)
4. Find the Duplicate Number (easy)
5. Find all Duplicate Numbers (easy)

## 7. 链表翻转

在众多问题中，题目可能需要你去翻转链表中某一段的节点。通常，要求都是你得原地翻转，就是重复使用这些已经建好的节点，而不使用额外的空间。这个时候，原地翻转模式就要发挥威力了。这种模式每次就翻转一个节点。一般需要用到多个变量，一个变量指向头结点（下图中的current），另外一个（previous）则指向咱们刚刚处理完的那个节点。在这种固定步长的方式下，你需要先将当前节点（current）指向前一个节点（previous），再移动到下一个。同时，你需要将previous总是更新到你刚刚新鲜处理完的节点，以保证正确性。

![img](3.常用算法.assets/v2-79af44147f0e31ef768b8867a43acac5_hd.jpg)

咱们怎么去甄别这种模式呢？

- 如果你被问到需要去翻转链表，要求不能使用额外空间的时候

### 经典题目

1. Reverse a LinkedList (easy)
2. Reverse a Sub-list (medium)
3. Reverse every K-element Sub-list (medium)

## 广度优先遍历/深度优先遍历

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [733. Flood Fill](https://leetcode-cn.com/problems/flood-fill/) | 🟢简单 |
| [695. Max Area of Island](https://leetcode-cn.com/problems/max-area-of-island/) | 🟡中等 |
|                                                              |       |
|                                                              |       |



## 8. 树上的BFS(广度优先遍历)

这种模式基于宽搜（Breadth First Search  (BFS)），适用于需要遍历一颗树。借助于队列数据结构，从而能保证树的节点按照他们的层数打印出来。打印完当前层所有元素，才能执行到下一层。所有这种需要遍历树且需要一层一层遍历的问题，都能用这种模式高效解决。这种树上的BFS模式是通过把根节点加到队列中，然后不断遍历直到队列为空。每一次循环中，我们都会把队头结点拿出来（remove），然后对其进行必要的操作。在删除每个节点的同时，其孩子节点，都会被加到队列中。识别树上的BFS模式：如果你被问到去遍历树，需要按层操作的方式（也称作层序遍历）

### 经典题目

1. Binary Tree Level Order Traversal (easy)-102
2. Reverse Level Order Traversal (easy)
3. Zigzag Traversal (medium)
4. Level Averages in a Binary Tree (easy)
5. Minimum Depth of a Binary Tree (easy)
6. Level Order Successor (easy)
7. Connect Level Order Siblings (medium)

## 9. 树上的DFS(深度优先遍历)

树形DFS基于深搜（Depth First Search (DFS)）技术来实现树的遍历。咱们可以用递归（或是显示栈，如果你想用迭代方式的话）来记录遍历过程中访问过的父节点。该模式的运行方式是从根节点开始，如果该节点不是叶子节点，我们需要干三件事：需要区别我们是先处理根节点（pre-order，前序），处理孩子节点之间处理根节点（in-order，中序），还是处理完所有孩子再处理根节点（post-order，后序）。递归处理当前节点的左右孩子。识别树形DFS：你需要按前中后序的DFS方式遍历树如果该问题的解一般离叶子节点比较近。

### 经典题目

1. Binary Tree Path Sum (easy)
2. All Paths for a Sum (medium)
3. Sum of Path Numbers (medium)
4. Path With Given Sequence (medium)
5. Count Paths for a Sum (medium)

## 10. 双堆类型

很多问题中，我们被告知，我们拿到一大把可以分成两队的数字。

为了解决这个问题，我们感兴趣的是，怎么把数字分成两半？使得：小的数字都放在一起，大的放在另外一半。双堆模式就能高效解决此类问题。正如名字所示，该模式用到了两个堆，是不是很难猜？

一个最小堆, 用来找最小元素；一个最大堆, 拿到最大元素。

这种模式将一半的元素放在最大堆中，这样你可以从这一堆中秒找到最大元素。同理，把剩下一半丢到最小堆中，O(1)时间找到他们中的最小元素。

通过这样的方式，这一大堆元素的**中位数**就可以从两个堆的堆顶拿到数字，从而计算出来。

### 适用场景

判断双堆模式的秘诀：这种模式在优先队列，计划安排问题（Scheduling）中有奇效如果问题让你找一组数中的最大/最小/中位数有时候，这种模式在涉及到二叉树数据结构时也特别有用

### 经典题目

1. Find the Median of a Number Stream (medium)
2. Sliding Window Median (hard)
3. Maximize Capital (hard)

## 11. 子集类型(多重DFS)

一般都是使用多重DFS

超级多的编程面试问题都会涉及到排列和组合问题。子集问题模式讲的是用BFS来处理这些问题。

这个模式是这样的：

1. 给一组数字 [1, 5, 3]
2. 我们从空集开始：[[]]
3. 把第一个数（1），加到之前已经存在的集合中：[[], [1]];
4. 把第二个数（5），加到之前的集合中得到：[[], [1], [5], [1,5]];
5. 再加第三个数（3），
6. 则有：[[], [1], [5], [1,5], [3], [1,3], [5,3], [1,5,3]].

该模式的详细步骤如下：

![img](3.常用算法.assets/v2-0409666e91e94287c167ef81670d19a5_hd.jpg)

如果判断这种子集模式：问题需要咱们去找数字的组合或是排列

### 经典题目

1. Subsets (easy)
2. Subsets With Duplicates (easy)
3. Permutations (medium)
4. String Permutations by changing case (medium)
5. Balanced Parentheses (hard)
6. Unique Generalized Abbreviations (hard)

## 12. 改造过的二分

当你需要解决的问题的输入是排好序的数组，链表，或是排好序的矩阵，要求咱们寻找某些特定元素。这个时候的不二选择就是二分搜索。这种模式是一种超级牛的用二分来解决问题的方式。

对于一组满足上升排列的数集来说，这种模式的步骤是这样的：

1. 首先，算出左右端点的中点。最简单的方式是这样的：middle = (start + end) / 2。但这种计算方式有不小的概率会出现整数越界。因此一般都推荐另外这种写法：middle = start + (end — start) / 2
2. 如果要找的目标改好和中点所在的数值相等，我们返回中点的下标就行
3. 如果目标不等的话：我们就有两种移动方式了
4. 如果目标比中点在的值小（key < arr[middle]）：将下一步搜索空间放到左边（end = middle - 1）
5. 如果比中点的值大，则继续在右边搜索，丢弃左边：left = middle + 1

图示该过程的话，如下图所示：

![img](3.常用算法.assets/v2-29f25eef886240f3ed3767039fb8f1db_hd.jpg)

### 经典题目

1. Order-agnostic Binary Search (easy)
2. Ceiling of a Number (medium)
3. Next Letter (medium)
4. Number Range (medium)
5. Search in a Sorted Infinite Array (medium)
6. Minimum Difference Element (medium)
7. Bitonic Array Maximum (easy)

| 题目                                                         | 难度 |
| ------------------------------------------------------------ | ---- |
| [35. Search Insert Position](https://leetcode-cn.com/problems/search-insert-position/) | 简单 |
| [278. First Bad Version](https://leetcode-cn.com/problems/first-bad-version/) | 简单 |
| [704. Binary Search](https://leetcode-cn.com/problems/binary-search/) | 简单 |
|                                                              |      |



## 13. 前K个系列

任何让我们求解最大/最小/最频繁的K个元素的题，都遵循这种模式。

用来记录这种前K类型的最佳数据结构就是堆了（译者注：在Java中，改了个名，叫优先队列（PriorityQueue））。这种模式借助堆来解决很多这种前K个数值的问题。

这个模式是这样的：

1. 根据题目要求，将K个元素插入到最小堆或是最大堆。
2. 遍历剩下的还没访问的元素，如果当前出来到的这个元素比堆顶元素大，那咱们把堆顶元素先删除，再加当前元素进去。

![img](3.常用算法.assets/v2-d42febfdf2d1ce2d2211e78ff8ea88db_hd.jpg)

注意这种模式下，咱们不需要去排序数组，因为堆具有这种良好的局部有序性，这对咱们需要解决问题就够了。识别最大K个元素模式：如果你需要求最大/最小/最频繁的前K个元素如果你需要通过排序去找一个特定的数

### 经典题目

1. Top ‘K’ Numbers (easy)
2. Kth Smallest Number (easy)
3. ‘K’ Closest Points to the Origin (easy)
4. Connect Ropes (easy)
5. Top ‘K’ Frequent Numbers (medium)
6. Frequency Sort (medium)
7. Kth Largest Number in a Stream (medium)
8. ‘K’ Closest Numbers (medium)
9. Maximum Distinct Elements (medium)
10. Sum of Elements (medium)
11. Rearrange String (hard)

## 14. 多路归并

K路归并能帮咱们解决那些涉及到多组排好序的数组的问题。每当你的输入是K个排好序的数组，你就可以用堆来高效顺序遍历其中所有数组的所有元素。你可以将每个数组中最小的一个元素加入到最小堆中，从而得到全局最小值。当我们拿到这个全局最小值之后，再从该元素所在的数组里取出其后面紧挨着的元素，加入堆。如此往复直到处理完所有的元素。

![img](3.常用算法.assets/v2-3e133c0710ef919e120fc74275d5255b_hd.jpg)

该模式是这样的运行的：

把每个数组中的第一个元素都加入最小堆中取出堆顶元素（全局最小），将该元素放入排好序的结果集合里面将刚取出的元素所在的数组里面的下一个元素加入堆重复步骤2，3，直到处理完所有数字识别K路归并：该问题的输入是排好序的数组，链表或是矩阵如果问题让咱们合并多个排好序的集合，或是需要找这些集合中最小的元素

### 经典题目

1. Merge K Sorted Lists (medium)
2. Kth Smallest Number in M Sorted Lists (Medium)
3. Kth Smallest Number in a Sorted Matrix (Hard)
4. Smallest Number Range (Hard)

## 15. 拓扑排序类型

拓扑排序模式用来寻找一种线性的顺序，这些元素之间具有依懒性。比如，如果事件B依赖于事件A，那A在拓扑排序顺序中排在B的前面。这种模式定义了一种简单方式来理解拓扑排序这种技术。

这种模式是这样奏效的：

1. 初始化
   1. 借助于HashMap将图保存成邻接表形式。
   2. 找到所有的起点，用HashMap来帮助记录每个节点的入度
2. 创建图，找到每个节点的入度
   1. 利用输入，把图建好，然后遍历一下图，将入度信息记录在HashMap中
3. 找所有的起点
   所有入度为0的节点，都是有效的起点，而且我们讲他们都加入到一个队列中
4. 排序
   1. 对每个起点，执行以下步骤
      1.  把它加到结果的顺序中
      2. 将其在图中的孩子节点取到
      3. 将其孩子的入度减少1
      4. 如果孩子的入度变为0，则改孩子节点成为起点，将其加入队列中
   2. 重复（a）过程，直到起点队列为空。

![img](3.常用算法.assets/v2-8a8abca46a67d38c1be674f9c777c8ef_hd.jpg)

拓扑排序模式识别：

待解决的问题需要处理无环图

你需要以一种有序的秩序更新输入元素

需要处理的输入遵循某种特定的顺序

### 经典题目

1. Topological Sort (medium)
2. Tasks Scheduling (medium)
3. Tasks Scheduling Order (medium)
4. All Tasks Scheduling Orders (hard)
5. Alien Dictionary (hard)

## 16. 贪心算法

前缀和

| 题目                                                         | 难度  |
| ------------------------------------------------------------ | ----- |
| [53. Maximum Subarray](https://leetcode-cn.com/problems/maximum-subarray/) | 🟢简单 |
|                                                              |       |
|                                                              |       |
|                                                              |       |



# 动态规划问题(DP)

## 0/1背包类型

经典题目：

0/1 Knapsack (medium)

Equal Subset Sum Partition (medium)

Subset Sum (medium)

Minimum Subset Sum Difference (hard)