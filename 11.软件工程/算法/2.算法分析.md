# █ 算法分析

衡量一个算法的优劣, 通常需要确定该算法的资源消耗量, 包括以下两个方面

- **时间复杂度**: 算法执行过程中指令执行的次数, 在同等性能的机器条件下, 指令执行的次数少则耗时更短
- **空间复杂度**: 算法执行过程中的内存占用情况

## 数学基础

为了比较不同算法资源的消耗, 需要在函数间建立一种**相对的级别**, 用来比较他们的**相对增长率**. 

首先熟悉几个数学概念:

- 如果存在正常数 c 和 n~0~  , 使得当 *N >= n~0~* 时, *T(N) <= cF(N)*, 称函数 F(n) 比 T(n) 有更快的增长率, 是 T(n) 的一个**上界**, 记作 `T(N) = O(F(N))`
- 如果存在正常数 c 和 n~0~  , 使得当 *N >= n~0~* 时, *T(N) >= cG(N)*, 称函数 G(n) 比 T(n) 有更慢的增长率, 是 T(n) 的一个**下界**, 记作 `T(N) = Ω(G(N))`
- 当且仅当  `T(N) = O(H(N))`和 `T(N) = Ω(H(N))` 同时成立时, 称函数 H(n) 与 T(N) 有相同级别的增长率(只是级别相同, 不一定精确相等), 记作  `T(N) = Θ(H(N))`
- 如果对于任意的 c, 都有 n~0~ 使得当 *N > n~0~* 时有 *T(N) < cP(N)*, 记作  `T(N) = o(P(N))`(小写字母o). 此时也满足 `T(N) = O(P(N))` 但 `T(N) != Θ(P(N))`

也可以通过计算 N 趋于正无穷时 F(N)/G(N) 的极限来确定相对增长率, 但通常不需要这么精确

- 极限=0: g(N) 有更快的增长率, 即 f(N) = o(g(N))
- 极限=c != 0: 两者有相同级别的增长率, 即 g(N) = Θ(f(N))
- 极限=无穷大: f(N) 有更快的增长率, 即 g(N) = o(f(N))
- 极限不存在, 二者无关, 一般不考虑这种情况

## 时间复杂度

通常, 程序的运行时间是我们关注的一个指标, 

另外, 由于磁盘的 I/O, 网络 I/O 等操作速度比 cpu 的计算速度要慢很多, 因此一旦程序内涉及到磁盘或网络 I/O, 运行时间会急剧增加. 因此, 算法分析时一般都认为数据已经完全读入, 不需要涉及 I/O 操作. 

为了简化分析, 我们规定一个理想的模型机, 并有以下约定

1. 模型机做任何一件简单工作都花费一个时间单位(则运行时间分析转换为操作计数)
2. 模型机有无限内存, 且算法的输入都已读入到内存中(消除 I/O 操作的干扰)
3. 抛弃前导的常数(没有特定的时间单位, 忽略单位换算的常数), 如 运行时间为 **4N**, 视为 **O(N)**
4. 抛弃低阶项(当 N 很大时, 低阶项可以忽略不计), 如 运行时间为 **N^2^+N+3**, 视为 **O(N^2^)**

若 *F(n) = O(f(n))*, *G(n) = O(g(n))*, 则

- F(n) + G(n) = `O(f(n))` + `O(g(n))` = `O(f(n) + g(n))` = max( f(n), g(n) )
- F(n) * G(n) = `O(f(n))` * `O(g(n))`

除了算法本身的优劣, 数据的输入也会对运行时间造成影响, 因为在分析算法时, 会讨论到三种情形:

- **最好情形**

  输入足够理想, 可以省略算法中的很多步骤, 花费资源最少

  通常脱离实际, 没有太大的意义

- **平均情形**: 

  典型情形, 大多数的输入都处在这个范围, 可以省略部分的操作步骤

  最符合实际情况, 但分析非常困难

- **最坏情形**

  输入足够差, 需要完整执行算法中的所有步骤, 花费资源最多

  可能过于悲观而得到一个偏大的结果, 但是它**代表了对任何可能输入的一种性能保证**, 一定能在给定的资源限制内完成. 

一般来说, 算法分析时主要讨论的就是**最坏情形**. 虽然 `O(f(N))` 的定义不如 `Θ(f(N))` 和 `o(f(N))` 那么精确和严谨, 但它已经能提供性能保证, 且证明难度较低, 因此使用更广泛.

#### 一般法则

1. **for 循环**

   循环次数 * 循环体运行时间, `O(N * O(body))`

2. **嵌套的for 循环**

   从里到外分析, 外层循环次数 * 外层循环体 = 外层N * 内层N * 内层循环体

3. **顺序语句**

   将各语句求和

4. **分支结构 if-else / switch**

   取最耗时的分支来计算

5. **递归类**

   如果一个算法用**常数时间**内的操作将问题**按比例**削减为其中的一部分(比如二分查找法, 处理一次后问题规模减小为原来的 1/2 ), 那么该算法就是 `O(log N)` 的.

   如果一个算法用**常数时间**内只是把问题减少一个常数的数量(比如递归地处理 f(n) = f(n-1)类的问题), 那么这种算法是 `O(N)` 的

### 实战技巧

1. 找到关键步骤
2. 判断关键步骤的执行次数, 当输入的数量变化时, 该关键步骤执行次数如何变化

### 常见算法的时间复杂度

| 算法                         | 时间复杂度 |          |
| ---------------------------- | ---------- | -------- |
| 数组定位, 如通过下标随机读写 | O(1)       | 常数时间 |
| 数组遍历, 如线性查找         | O(N)       | 线性时间 |
| 分治算法, 如二分查找         | O(logN)    | 对数时间 |
| 快速排序                     | O(N*logN)  |          |
| 选择排序                     | O(N^2^)    |          |
|                              |            |          |

**联机算法**(online algorithm): 在任意时刻, 算法都能对它已经读入的数据给出当前数据集内的答案, 可以以流式处理无限大的数据集. 仅需要常量空间并以线性时间运行的联机算法几乎是完美的.



## 摊还分析

每次操作的最坏情形并不太理想, 但如果M次操作总的最坏情形运行时间是 `O(Mf(N))` 时, 我们就说它的摊还运行时间为`O(f(N))`, 称为**摊还时间界**.



## 空间复杂度