# █ 算法分析

## 时间复杂度

通常, 程序的运行时间是我们关注的一个指标, 除了算法本身的优劣, 数据的输入也会对运行时间造成影响, 因为在分析算法时, 会讨论到三种情形:

- **最好情形**

  输入足够理想, 可以省略算法中的很多步骤, 花费时间最少

  通常脱离实际, 没有太大的意义

- **平均情形**: 

  典型情形, 大多数的输入都处在这个范围, 可以省略部分的操作步骤

  最符合实际情况, 但分析非常困难

- **最坏情形**

  输入足够差, 需要完整执行算法中的所有步骤, 花费时间最多

  可能过于悲观而得到一个偏大的结果, 但是它**代表了对任何可能输入的一种性能保证**, 一定能在指定时间内完成. 

一般来说, 算法分析时主要讨论的就是**最坏情形**. 

另外, 由于磁盘的 I/O, 网络 I/O 等操作速度比 cpu 的计算速度要慢很多, 因此一旦程序内涉及到磁盘或网络 I/O, 运行时间会急剧增加. 因此, 算法分析时一般都认为数据已经完全读入, 不需要涉及 I/O 操作. 

#### 简化法则

为了简化分析, 我们规定一个理想的模型机, 并有以下约定

1. 模型机做任何一件简单工作都花费一个时间单位(则运行时间分析转换为操作计数)
2. 模型机有无限内存, 且算法的输入都已读入到内存中(消除 I/O 操作的干扰)
3. 抛弃前导的常数, 如 运行时间为 **4N**, 视为 **O(N)**
4. 抛弃低阶项, 如 运行时间为 **N^2^+N+3**, 视为 **O(N^2^)**

若 *F(n) = O(f(n))*, *G(n) = O(g(n))*, 则

- F(n) + G(n) = `O(f(n))` + `O(g(n))` = `O(f(n) + g(n))` = max( f(n), g(n) )
- F(n) * G(n) = `O(f(n))` * `O(g(n))`

#### 一般法则

1. for 循环

   循环次数 * 循环体运行时间, `O(N * O(body))`

2. 嵌套的for 循环

   从里到外分析, 外层循环次数 * 外层循环体 = 外层N * 内层N * 内层循环体

3. 顺序语句

   将各语句求和

4. 分支结构 if-else / switch

   取最耗时的分支来计算

5. 递归类

   如果一个算法用**常数时间**内的操作将问题**按比例**削减为其中的一部分(比如二分查找法, 处理一次后问题规模减小为原来的 1/2 ), 那么该算法就是 `O(log N)` 的.

   如果一个算法用**常数时间**内只是把问题减少一个常数的数量(比如递归地处理 f(n) = f(n-1)类的问题), 那么这种算法是 `O(N)` 的

### 实战技巧

1. 找到关键步骤
2. 判断关键步骤的执行次数, 当输入的数量变化时, 该关键步骤执行次数如何变化

## 空间复杂度