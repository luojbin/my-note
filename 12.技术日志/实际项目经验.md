## 乐观锁处理抽奖

```java
@Transactional(value = "transactionManager", propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, rollbackFor = Exception.class)
public void doLuckyDraw(LuckyDraw luckyDraw, String openId, String appId, QuestionAnswerSheet sheet) {
    Integer luckyDrawId = luckyDraw.getId();
    String createTime = DateUtils.toStr();
    int optimisticLockFlag = 0;
    while(optimisticLockFlag == 0) {
        List<LuckyDrawParticipant> participantList = luckyDrawParticipantMapper.getListByLuckyDrawId(luckyDrawId);
        int rowCount = participantList.size();

        // 这个用户已经抽过奖, 不能重复抽奖
        LuckyDrawResultDTO exist = luckyDrawParticipantMapper.getByLuckyDrawIdAndOpenId(luckyDrawId, openId);
        if (exist != null) {
            break;
        }

        // 默认不中奖
        LuckyDrawParticipant participant = new LuckyDrawParticipant();
        participant.setLuckyDrawId(luckyDrawId);
        participant.setAppId(appId);
        participant.setOpenId(openId);
        participant.setStatus(LuckyDrawParticipantStatusEnum.NOT_WIN.getCode());
        participant.setName(sheet.getName());
        participant.setCreateTime(createTime);

        if (participantList.size() >= luckyDraw.getMaxDrawCount()) {
            // 参与人数已经达到上限, 奖品理应全部送出, 不抽奖
            luckyDrawParticipantMapper.insert(participant);
            break;
        }

        // 总奖品数
        List<LuckyDrawPrize> prizeList = luckyDrawPrizeMapper.getListByLuckyDrawId(luckyDrawId);
        Integer totalPrizeCount = prizeList.stream().mapToInt(LuckyDrawPrize::getPrizeCount).sum();
        // 已送出奖品数
        Map<Integer, Integer> prizeCountMap = prizeList.stream().collect(Collectors.toMap(LuckyDrawPrize::getId, p -> 0));
        participantList.forEach(pp -> {
            if (pp.getLuckyDrawPrizeId() != null) {
                prizeCountMap.merge(pp.getLuckyDrawPrizeId(), 1, Integer::sum);
            }
        });
        Integer totalWinnerCount = prizeCountMap.values().stream().mapToInt(pc -> pc).sum();

        if (totalPrizeCount <= totalWinnerCount) {
            // 奖品已全部送出, 不抽奖
            luckyDrawParticipantMapper.insert(participant);
            break;
        }

        // 剩余奖品数
        int remainedPrizeCount = totalPrizeCount - totalWinnerCount;
        int possibleWinnerCount = luckyDraw.getMaxDrawCount() - participantList.size();

        /*
           是否中奖?
           随机数 [0-可抽奖人数), 当随机数小于奖品数时, 视为中奖
           比如 可参与抽奖人数 10, 剩余奖品 3
           则 随机数的可能范围为 {0,1,2,3,4,5,6,7,8,9}
           当随机数小于奖品数3 (随机数 in {0,1,2}) 时, 视为中奖
        */
        boolean win = (int) (Math.random() * possibleWinnerCount) < remainedPrizeCount;
        if (!win) {
            // 没有中奖, 这里也需要用乐观锁插入, 避免参与人数过多而奖品没发完
            optimisticLockFlag = luckyDrawParticipantMapper.optimisticLockInsert(participant, rowCount);
            // 不确定插入成功了没有, 进行下一循环以判断 optimisticLockFlag
            continue;
        }

        // 看看中个什么奖
        List<LuckyDrawPrize> availablePrizeList = prizeList.stream()
            .filter(p -> p.getPrizeCount() > prizeCountMap.get(p.getId()))
            .collect(Collectors.toList());
        int prizeIndex = (int) (Math.random() * availablePrizeList.size());
        int prizeId = availablePrizeList.get(prizeIndex).getId();

        // 记录中奖结果
        participant.setLuckyDrawPrizeId(prizeId);
        participant.setStatus(LuckyDrawParticipantStatusEnum.PENDING_AWARD.getCode());
        optimisticLockFlag = luckyDrawParticipantMapper.optimisticLockInsert(participant, rowCount);
    }
}
```

关键sql, 满足条件时才插入

```sql
insert into lucky_draw_participant (
            LUCKY_DRAW_ID,
            LUCKY_DRAW_PRIZE_ID,
            APP_ID,
            OPEN_ID,
            STATUS,
            NAME,
            MOBILE,
            EMAIL,
            COMPANY,
            POSITION,
            CITY,
            CREATE_TIME,
            UPDATE_TIME
)
(select
         #{entity.luckyDrawId},
         #{entity.luckyDrawPrizeId},
         #{entity.appId},
         #{entity.openId},
         #{entity.status},
         #{entity.name},
         #{entity.mobile},
         #{entity.email},
         #{entity.company},
         #{entity.position},
         #{entity.city},
         #{entity.createTime},
         #{entity.updateTime}
where (select count(*) 
       from lucky_draw_participant 
       where LUCKY_DRAW_ID = #{entity.luckyDrawId}
      ) = #{rowCount});
```



## 用单线程连接池限制并发



## 用外观模式解决mock静态方法



## 用切面记录更新日志