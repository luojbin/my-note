# 监控器配置

spring starter 自动配置

```java
@Configuration
@EnableConfigurationProperties(ThreadPoolMonitorConfigurationProperties.class)
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
@ConditionalOnProperty(prefix = "crm.kit.monitor.thread", name = "enabled", havingValue = "true", matchIfMissing = false)
@Slf4j
public class ThreadPoolMonitorAutoConfiguration {

    @Bean
    public ThreadPoolMonitorKit threadPoolMonitorKit(ThreadPoolMonitorConfigurationProperties threadPoolMonitorConfigurationProperties) {
        log.info("线程池监控自动配置成功");
        return new ThreadPoolMonitorKit(threadPoolMonitorConfigurationProperties);
    }

    @Bean
    public ThreadPoolMonitorController threadPoolMonitorController(ThreadPoolMonitorKit threadPoolMonitorKit) {
        return new ThreadPoolMonitorController(threadPoolMonitorKit);
    }

    @Bean
    public ApplicationRunner applicationRunner(ThreadPoolMonitorKit threadPoolMonitorKit) {
        return arg -> {
            if (threadPoolMonitorKit.getProperties().getTimerDefaultStart()) {
                log.info("启动线程池监控，间隔{}秒", threadPoolMonitorKit.getProperties().getTimerDefaultSeconds());
                threadPoolMonitorKit.startTimer(threadPoolMonitorKit.getProperties().getTimerDefaultSeconds());
            }
        };
    }
}
```

自动配置参数, 可以在 `application.yml`中使用

```java
@Data
@ConfigurationProperties(prefix = "crm.kit.monitor.thread")
public class ThreadPoolMonitorConfigurationProperties {

    /**
     * 是否启用线程池监控自动配置【自动注册ThreadPoolMonitorKit和ThreadPoolMonitorController】，默认不启用
     */
    private Boolean enabled = false;

    /**
     * 线程池状态记录表
     */
    private String table = "thread_pool_status_log";

    /**
     * 应用启动时是否定时收集线程池状态，默认否
     */
    private Boolean timerDefaultStart = false;

    /**
     * 自动收集间隔秒数，默认5分钟
     */
    private int timerDefaultSeconds = 5 * 60;
}
```

`application.yml` 中的配置

```yml
...

crm:
  kit:
    monitor:
      # 线程池状监控，定时收集线程池状态
      thread:
        enabled: true
        timer-default-start: true
```

# 监控器工作原理

`startTimer` 方法开启一个新线程, 作为监控线程

通过一个定时器, 从spring容器中获取线程池, 获取线程池的内容并记录日志到数据库

`getExecutors`方法是通过 spring 获取 `Executor`的bean, 因此该监控器只能监控注册到 spring 的线程池

```java
@Slf4j
public class ThreadPoolMonitorKit {

    @Getter
    private final ThreadPoolMonitorConfigurationProperties properties;
    private volatile boolean timerRunning = false;
    private volatile long timerSeconds = Long.MAX_VALUE;
    private long timerStartTime;

    public ThreadPoolMonitorKit(ThreadPoolMonitorConfigurationProperties threadPoolMonitorConfigurationProperties) {
        this.properties = threadPoolMonitorConfigurationProperties;
    }

    public Map<String, List<String>> getPools() {
        DataSourceLogger.Query query = new DataSourceLogger.Query(properties.getTable())
                .append("group by concat(APP_NAME, BEAN_NAME)");
        try {
            List<ThreadPoolStatusLog> list = DataSourceLogger.selectLogs(query, DataSourceLogger.resultSetToBeanTranslator(ThreadPoolStatusLog.class));
            return list.stream().collect(Collectors.groupingBy(ThreadPoolStatusLog::getAppName,
                    Collectors.mapping(ThreadPoolStatusLog::getBeanName, Collectors.toList())));
        } catch (Exception e) {
            log.error("TreadMonitor select log failed", e);
            throw new RuntimeException("查询日志失败");
        }
    }

    public ResultUtil getLogList(Integer pageNo, Integer pageSize, String appName, String beanName, String startTime, String endTime) {
        pageNo = pageNo == null ? 1 : pageNo;
        pageSize = pageSize == null ? 20 : pageSize;
        try {
            DataSourceLogger.Query query = new DataSourceLogger.Query(properties.getTable())
                    .andEq("APP_NAME", appName)
                    .andEq("BEAN_NAME", beanName)
                    .andGe("CREATE_TIME", startTime)
                    .andLe("CREATE_TIME", endTime)
                    .append("order by ID desc")
                    .page(pageNo, pageSize);
            List<ThreadPoolStatusLog> list = DataSourceLogger.selectLogs(query, DataSourceLogger.resultSetToBeanTranslator(ThreadPoolStatusLog.class));
            return ResultUtil.ok("total", query.getTotal())
                    .set("page", pageNo)
                    .set("pageSize", pageSize)
                    .data(list);
        } catch (Exception e) {
            log.error("TreadMonitor select log failed", e);
            throw new RuntimeException("查询日志失败");
        }
    }

    public void collectLog() {
        for (Map.Entry<String, Executor> entry : getExecutors().entrySet()) {
            final Executor executor = entry.getValue();
            if (executor instanceof ThreadPoolTaskExecutor) {
                saveLog(entry.getKey(), ((ThreadPoolTaskExecutor) executor).getThreadPoolExecutor());
            }
        }
    }

    public void startTimer(long seconds) {
        if (this.timerRunning) {
            throw new RuntimeException("定时器已经启动");
        }
        if (seconds < 3) {
            throw new RuntimeException("定时器间隔不能小于3秒");
        }
        this.timerRunning = true;
        this.timerSeconds = seconds;
        this.timerStartTime = System.currentTimeMillis();
        // 新起一个线程，循环收集线程状态，直到外部设置timerRunning=false
        new Thread(() -> {
            while (this.timerRunning) {
                collectLog();
                try {
                    TimeUnit.SECONDS.sleep(this.timerSeconds);
                } catch (InterruptedException e) {
                    log.warn("timer interrupted", e);
                    this.timerRunning = false;
                }
            }
        }).start();
    }

    public void stopTimer() {
        this.timerRunning = false;
    }

    public Map<String, Object> getTimerStatus() {
        Map<String, Object> statusMap = new HashMap<>();
        statusMap.put("timerRunning", this.timerRunning);
        statusMap.put("timerSeconds", this.timerSeconds);
        statusMap.put("timerStartTime", this.timerStartTime);
        return statusMap;
    }

    private Map<String, Executor> getExecutors() {
        return ApplicationContextHolder.applicationContext.getBeansOfType(Executor.class);
    }

    private void saveLog(String beanName, ThreadPoolExecutor executor) {
        try {
            ThreadPoolStatusLog log = new ThreadPoolStatusLog();
            log.setAppName(ApplicationContextHolder.applicationContext.getEnvironment().getProperty("spring.application.name"));
            log.setBeanName(beanName);
            log.setTaskCount(executor.getTaskCount());
            log.setCompletedTaskCount(executor.getCompletedTaskCount());
            log.setActiveCount(executor.getActiveCount());
            log.setQueueSize(executor.getQueue().size());
            log.setPoolSize(executor.getPoolSize());
            log.setMaxPoolSize(executor.getMaximumPoolSize());
            log.setLargestPoolSize(executor.getLargestPoolSize());
            log.setCreateTime(DateUtils.toStr());
            DataSourceLogger.saveLog(properties.getTable(), log);
        } catch (SQLException exception) {
            log.warn("保存日志失败", exception);
        }
    }
}
```

日志结构

```java
@Data
public class ThreadPoolStatusLog {

    private Long id;

    /**
     * 应用名称
     */
    private String appName;

    /**
     * 线程池名称
     */
    private String beanName;

    /**
     * 总任务数
     */
    private Long taskCount;

    /**
     * 已完成任务数
     */
    private Long completedTaskCount;

    /**
     * 正在执行的任务数
     */
    private Integer activeCount;

    /**
     * 正在排队的任务数
     */
    private Integer queueSize;

    /**
     * 线程池线程数
     */
    private Integer poolSize;

    /**
     * 线程池最大线程数
     */
    private Integer maxPoolSize;

    /**
     * 线程池历史最大线程数
     */
    private Integer largestPoolSize;

    /**
     * 数据插入时间
     */
    private String createTime;
}
```

由于我们将监控器相关代码封装到自定义 starter, starter 本身未提供数据库访问功能, 需要从应用的 spring 容器中获取数据库连接, 才能将日志记录到数据库

```java
/**
 * 数据库日志类，从ApplicationContext中获取DataSource，然后使用Jdbc保存日志
 *
 * @author zhouwei
 * @date 2020/9/11 11:38
 */
@Slf4j
public class DataSourceLogger {

    private static final String INSERT_SQL = "insert into `%s`(%s) values(%s)";
    private static final String SELECT_SQL = "select * from `%s` where 1=1";

    /**
     * 保存日志
     * @param table 数据库表名，字段从实体读取并转换为下划线风格
     * @param bean 表对应的实体，忽略ID、null字段和静态字段
     * @return 自增主键
     */
    public static Object saveLog(String table, Object bean) throws SQLException {
        if (StringUtil.isEmpty(table) || bean == null) {
            return null;
        }
        // 过滤掉null字段
        List<Field> fields = Stream.of(bean.getClass().getDeclaredFields())
                .filter(f -> fieldFilter(f, bean))
                .collect(Collectors.toList());
        if (CollectionUtils.isEmpty(fields)) {
            return null;
        }
        String columns = fields.stream()
                .map(f -> "`" + f.getName() + "`")
                .map(DataSourceLogger::camelCaseToUnderCase)
                .collect(Collectors.joining(", "));
        List<Object> values = fields.stream()
                .map(f -> getFiledValue(f, bean))
                .collect(Collectors.toList());
        // 使用预编译方式传参，防止sql注入
        final String valuePlaceHolders = values.stream().map(v -> "?").collect(Collectors.joining(", "));
        String sql = String.format(INSERT_SQL, table, columns, valuePlaceHolders);
        log.debug("sql: {}\n sql param: {}", sql, values);

        Object id = null;
        DataSource dataSource = ApplicationContextHolder.applicationContext.getBean(DataSource.class);
        try (Connection connection = dataSource.getConnection()) {
            final PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            for (int i = 0; i < values.size(); i++) {
                preparedStatement.setObject(i + 1, values.get(i));
            }
            preparedStatement.execute();
            ResultSet generatedKeys = preparedStatement.getGeneratedKeys();
            if (generatedKeys.next()) {
                id = generatedKeys.getObject(1);
            }
        }
        return id;
    }

    public static <T> List<T> selectLogs(Query query, Function<ResultSet, List<T>> resultSetTranslator) throws Exception {
        log.debug("{}\n{}", query.getSql(), query.getParams());

        DataSource dataSource = ApplicationContextHolder.applicationContext.getBean(DataSource.class);
        try (Connection connection = dataSource.getConnection()) {
            final PreparedStatement preparedStatement = connection.prepareStatement(query.getSql().toString());
            for (int i = 0; i < query.getParams().size(); i++) {
                preparedStatement.setObject(i + 1, query.getParams().get(i));
            }
            final ResultSet resultSet = preparedStatement.executeQuery();
            return resultSetTranslator.apply(resultSet);
        }
    }

    public static <T> Function<ResultSet, List<T>> resultSetToBeanTranslator(Class<T> tClass) {
        return resultSet -> {
            try {
                List<String> columnLabels = new ArrayList<>();
                ResultSetMetaData metaData = resultSet.getMetaData();
                for (int i = 1; i <= metaData.getColumnCount(); i++) {
                    columnLabels.add(metaData.getColumnLabel(i));
                }
                List<T> list = new ArrayList<>();
                while (resultSet.next()) {
                    T bean = tClass.newInstance();
                    if (bean instanceof Map) {
                        for (String label : columnLabels) {
                            ((Map) bean).put(underCaseToCamelCase(label), resultSet.getObject(label));
                        }
                    } else {
                        BeanWrapperImpl beanWrapper = new BeanWrapperImpl(bean);
                        for (String label : columnLabels) {
                            beanWrapper.setPropertyValue(underCaseToCamelCase(label), resultSet.getObject(label));
                        }
                    }
                    list.add(bean);
                }
                return list;
            } catch (Exception exception) {
                throw new RuntimeException(exception);
            }
        };
    }

    private static boolean fieldFilter(Field f, Object log) {
        return  // 不要ID
                !"ID".equalsIgnoreCase(f.getName())
                // 不要null
                && getFiledValue(f, log) != null
                // 不要静态变量
                && !Modifier.isStatic(f.getModifiers());
    }

    private static Object getFiledValue(Field f, Object target) {
        f.setAccessible(true);
        try {
            return f.get(target);
        } catch (IllegalAccessException e) {
            return null;
        }
    }

    private static String camelCaseToUnderCase(String camelCase) {
        return camelCase.replaceAll("([A-Z])", "_$1").replaceFirst("^_", "").toUpperCase();
    }

    private static String underCaseToCamelCase(String underCase) {
        final String[] s = underCase.toLowerCase().split("_");
        return s[0] + Stream.of(s).skip(1).filter(item -> !StringUtil.isEmpty(item))
                .map(item -> String.valueOf(item.charAt(0)).toUpperCase() + item.substring(1))
                .collect(Collectors.joining());
    }

    @Data
    public static class Query {
        private StringBuilder sql;
        private List<Object> params;
        private long total;

        public Query() {
            this.sql = new StringBuilder();
            this.params = new ArrayList<>();
        }

        public Query(String table) {
            this.sql = new StringBuilder(String.format(SELECT_SQL, table));
            this.params = new ArrayList<>();
        }

        public Query append(String sql) {
            this.sql.append(" ").append(sql);
            return this;
        }

        public Query append(String sql, Object value) {
            if (value == null || "".equals(value)) {
                return this;
            }
            this.sql.append(" ").append(sql);
            this.params.add(value);
            return this;
        }

        public Query andEq(String column, Object value) {
            return append(String.format(" and %s = ?", column), value);
        }

        public Query andLe(String column, Object value) {
            return append(String.format(" and %s <= ?", column), value);
        }

        public Query andGe(String column, Object value) {
            return append(String.format(" and %s >= ?", column), value);
        }

        public Query page(int pageNo, int pageSize) throws SQLException {
            DataSource dataSource = ApplicationContextHolder.applicationContext.getBean(DataSource.class);
            try (Connection connection = dataSource.getConnection()) {
                String countSql = this.getSql().toString().replace("select *", "select count(*)");
                log.debug("{}\n{}", countSql, params);

                PreparedStatement preparedStatement = connection.prepareStatement(countSql);
                for (int i = 0; i < params.size(); i++) {
                    preparedStatement.setObject(i + 1, params.get(i));
                }
                ResultSet resultSet = preparedStatement.executeQuery();
                if (resultSet.next()) {
                    this.total = resultSet.getLong(1);
                } else {
                    this.total = 0;
                }
            }
            int skip = (pageNo - 1) * pageSize;
            return this.append(String.format("limit %s, %s", skip, pageSize));
        }
    }

}
```

# 线程池相关操作

```java
/*
 * 1. 不用@RestController注解，只当某个应用引入crm-kit，并配置crm.kit.monitor.thread.enabled时，本Controller生效
 * 2. 多个应用的日志表相同时，本Controller可以查询到别的应用的线程池状态日志
 * 3. 仅针对IOC容器中，注册为Executor的ThreadPoolTaskExecutor
 */

/**
 * 线程池状态
 */
@RequestMapping("monitor/threadPool")
@ResponseBody
public class ThreadPoolMonitorController {

    private final ThreadPoolMonitorKit threadPoolMonitorKit;

    public ThreadPoolMonitorController(ThreadPoolMonitorKit threadPoolMonitorKit) {
        this.threadPoolMonitorKit = threadPoolMonitorKit;
    }

    /**
     * 获取所有应用的线程池
     */
    @GetMapping("getPools")
    public ResultUtil getPools() {
        try {
            return ResultUtil.ok().data(threadPoolMonitorKit.getPools());
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }

    /**
     * 查询线程池状态
     * @param page 页码
     * @param pageSize 每页大小
     * @param appName 应用名称
     * @param beanName 线程池名称
     * @param startTime 开始时间
     * @param endTime 结束时间
     */
    @GetMapping("getLogList")
    public ResultUtil getLogList(
            Integer page,
            Integer pageSize,
            String appName,
            String beanName,
            String startTime,
            String endTime) {
        try {
            return threadPoolMonitorKit.getLogList(page, pageSize, appName, beanName, startTime, endTime);
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }

    /**
     * 收集一次线程池状态，仅本应用有效
     */
    @PostMapping("collectLog")
    public ResultUtil collectLog() {
        try {
            threadPoolMonitorKit.collectLog();
            return ResultUtil.ok();
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }

    /**
     * 开始定时收集线程池状态，仅本应用有效
     * @param seconds 定时器间隔，单位秒
     */
    @PostMapping("startTimer")
    public ResultUtil startTimer(@RequestParam int seconds) {
        try {
            threadPoolMonitorKit.startTimer(seconds);
            return ResultUtil.ok();
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }

    /**
     * 停止定时收集线程池状态，仅本应用有效
     */
    @PostMapping("stopTimer")
    public ResultUtil stopTimer() {
        try {
            threadPoolMonitorKit.stopTimer();
            return ResultUtil.ok();
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }

    /**
     * 查询定时器状态，仅本应用有效
     */
    @GetMapping("getTimerStatus")
    public ResultUtil getTimerStatus() {
        try {
            threadPoolMonitorKit.getTimerStatus();
            return ResultUtil.ok();
        } catch (Exception e) {
            return ResultUtil.fail().msg(e.getMessage());
        }
    }
}
```

